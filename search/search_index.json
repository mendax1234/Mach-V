{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Mach-V Documentation","text":"<p>Welcome to the Mach-V Documentation!</p>"},{"location":"sim/","title":"Simulation","text":"<p>This section outlines the verification strategy for the Mach-V processor.</p>"},{"location":"sim/#simulation-directory-structure","title":"Simulation Directory Structure","text":"<p>The <code>sim/</code> directory contains all testbench and verification artifacts:</p> <ul> <li><code>sim/tb/</code>: Verilog testbenches mapped to specific software applications.</li> <li><code>sim/mem/</code>: Pre-compiled memory files (in hexadecimal format) used to initialize IROM and DMEM for simulation.</li> </ul>"},{"location":"sim/#toolchain-setup","title":"Toolchain Setup","text":"<p>The primary tool used for simulation is Vivado 2025.2. For installation instructions, refer to the NUS CG3207 Lab Guide or consult the official Xilinx documentation.</p>"},{"location":"sim/#simulation-guide","title":"Simulation Guide","text":"<p>Simulations for Mach-V are performed by targeting the Wrapper.v module as the Device Under Test (DUT). Acting effectively as a virtual motherboard, this module connects the processor core to peripherals like UART and memory.</p>"},{"location":"sim/#debugging-the-pipelined-processor","title":"Debugging the Pipelined Processor","text":"<p>Personally speaking, debugging a pipelined microarchitecture can be tedious due to instructions overlapping across different stages. To simplify this process, I recommend propagating the current PC value through every stage of the pipeline.</p> <p>By latching <code>PCF</code> into successive pipeline registers (e.g., <code>PCD</code>, <code>PCE</code>, <code>PCM</code>, <code>PCW</code>), you can easily identify exactly which instruction is occupying a specific stage at any given cycle.</p> <p>For example, the waveform below shows the Decode (Dec) stage while executing the Coremark application:</p> <p></p> <p>Decode Stage with PC Propagation</p> <p>In the waveform above, the <code>PCD</code> signal indicates the instruction currently residing in the Dec stage. This makes it significantly easier to verify if the control signals match the expected behavior. For reference, here is the corresponding snippet from <code>prog.dump</code>:</p> <pre><code>400000:   0080006f           j 400008 &lt;_init_reg&gt;\n400004:   0000006f           j 400004 &lt;_end&gt;\n400008:   00000093           li ra,0\n40000c:   00000113           li sp,0\n400010:   00000193           li gp,0\n400014:   00000213           li tp,0\n</code></pre> <p>Warning</p> <p>While this method has been effective for Phase 2 of Mach-V, there may be more efficient debugging techniques. I will continue to explore other methods and update this section as the design evolves.</p>"},{"location":"sim/#handling-fly-away-situations-undefined-states","title":"Handling \"Fly-Away\" Situations (Undefined States)","text":"<p>Occasionally, you may encounter a situation where signals (such as <code>PCF</code>) suddenly transition to <code>XXX</code> (undefined). This usually indicates that the processor has entered an invalid state. These issues can be difficult to trace, but below are some common causes I have encountered.</p> <p>Rule of Thumb</p> <p>Locate the last valid instruction in the waveform before the signals go undefined. Use the PC value of that instruction to find the corresponding RISC-V instruction in your <code>prog.dump</code> file (generated after running <code>make</code>).</p>"},{"location":"sim/#lw-loading-from-an-invalid-address","title":"<code>lw</code> Loading from an Invalid Address","text":"<p>This issue typically occurs when a load instruction attempts to access an address that is not mapped to the DMEM. If the data is missing from the memory initialization, the simulation returns undefined values.</p> <p>To resolve this, check if the source address of the load instruction falls within a section that has been put into the DMEM. This kind of information is specified in the linker script (<code>ld.script</code>).</p> <p>Tip</p> <p>A common pitfall is the <code>.rodata</code> (read-only data) section. Ensure that <code>.rodata</code> is explicitly included in the DMEM mapping in your linker script.</p>"},{"location":"sim/benchmark_tb/","title":"Benchmark Testbench","text":"<p>This testbench is designed for non-interactive applications, such as the CoreMark benchmark. Its primary goal is to run the processor at full speed and capture the output without requiring manual user input.</p>"},{"location":"sim/benchmark_tb/#key-features","title":"Key features","text":""},{"location":"sim/benchmark_tb/#zero-stall-uart-configuration","title":"Zero-Stall UART Configuration","text":"<p>Since the benchmark relies on printf for reporting results but has no human operator, the UART input is disabled, and the output is forced to be \"always ready.\"</p> <ul> <li>RX (Input): <code>UART_RX_valid</code> is tied to <code>0</code>, ensuring the CPU never receives spurious input.</li> <li>TX (Output): <code>UART_TX_ready</code> is hardcoded to <code>1</code>, preventing the CPU from stalling while waiting for the terminal to accept a character.</li> </ul>"},{"location":"sim/benchmark_tb/#output-monitoring","title":"Output Monitoring","text":"<p>Instead of opening a graphical terminal, the testbench monitors the <code>UART_TX</code> line directly. Whenever the CPU asserts <code>UART_TX_valid</code>, the testbench grabs the character and prints it to the Vivado Tcl console using <code>$display</code>.</p> <pre><code>always @(posedge CLK) begin\n    if (UART_TX_valid) begin\n        // Prints the ASCII character sent by the CPU\n        $display(\"UART_TX: %h\", UART_TX); \n    end\nend\n</code></pre>"},{"location":"sim/benchmark_tb/#simulation-timeout","title":"Simulation Timeout","text":"<p>To prevent the simulation from running indefinitely (in case of software crashes or infinite loops), a hard limit is set. The simulation automatically stops after 50ms (5,000,000,000 ns), which is sufficient for one iteration of the benchmark.</p>"},{"location":"sim/uart_tb/","title":"UART Application Testbench","text":"<p>This testbench verifies the interactive capabilities of the processor, specifically focusing on the UART Calculator application. Unlike the benchmark simulation, this testbench actively injects data and adheres to a strict handshaking protocol.</p>"},{"location":"sim/uart_tb/#the-send_uart-task","title":"The <code>send_uart</code> Task","text":"<p>The core of this verification is the <code>send_uart</code> task, which automates the entry of complex commands. It constructs a 9-byte packet consisting of:</p> <ol> <li>Command Byte: The ASCII character for the operation. (e.g., <code>d</code> for division. For the full list of commands, refer to the UART Calculator documentation.)</li> <li>Operand 1 (4 bytes): The first 32-bit number.</li> <li>Operand 2 (4 bytes): The second 32-bit number.</li> </ol>"},{"location":"sim/uart_tb/#handshaking-protocol","title":"Handshaking Protocol","text":"<p>The task simulates a real UART controller by waiting for the CPU to acknowledge receipt of each byte before sending the next.</p> <pre><code>// Wait until CPU acknowledges (reads from UART_RX)\nwait (UART_RX_ack == 1); \nUART_RX_valid = 0;\n// Wait until CPU clears ack before sending next byte\nwait (UART_RX_ack == 0);\n</code></pre>"},{"location":"sim/uart_tb/#test-coverage","title":"Test Coverage","text":"<p>You are encouraged to extend tb_uart.v with additional test cases to verify specific scenarios. When adding new tests, please refer to the UART Calculator Command Reference to ensure the correct the command code is used.</p>"},{"location":"sw/","title":"Software Development Guide","text":"<p>This guide explains how to write, compile, and run different software on the Mach-V processor.</p>"},{"location":"sw/#software-directory-structure","title":"Software Directory Structure","text":"<p>The <code>sw/</code> directory is organized by application. For example:</p> <ul> <li><code>sw/coremark/</code> contains the CoreMark benchmark source code and build scripts.</li> </ul>"},{"location":"sw/#system-memory-map","title":"System Memory Map","text":"<p>Followed by the convention set in NUS CG3207, the Mach-V processor uses a memory-mapped I/O architecture. The address space is divided into Instruction Memory, Data Memory, and Peripheral (MMIO) regions.</p> <p>Configuration Source</p> <p>The memory capacities defined below are determined by parameters in <code>Wrapper.v</code>. For example, <pre><code>localparam IROM_DEPTH_BITS = 15;     // for 2^15 words = 32KB\nlocalparam DMEM_DEPTH_BITS = 14;     // for 2^14 words = 16KB\nlocalparam MMIO_DEPTH_BITS = 8;      // for 2^8 words = 1KB\n</code></pre></p> <p>If you modify these parameters in <code>Wrapper.v</code>, you must update your linker script and stack initialization accordingly.</p>"},{"location":"sw/#main-memory","title":"Main Memory","text":"Address Range Name Permissions Description <code>0x00400000 \u2013 0x00407FFF</code> IROM (Instruction Memory) RO (Read-Only) Capacity: 8,192 words (32 KB). Based on <code>IROM_DEPTH_BITS = 15</code>. <code>0x10010000 \u2013 0x10013FFF</code> DMEM (Data Memory) RW (Read-Write) Capacity: 4,096 words (16 KB). Used for storing constants and variables. Based on <code>DMEM_DEPTH_BITS = 14</code>. <p>Addressing Constraints</p> <p>Accesses must be aligned to 4-byte boundaries.</p>"},{"location":"sw/#memory-mapped-peripherals-mmio","title":"Memory-Mapped Peripherals (MMIO)","text":"<p>All peripherals are mapped to the upper memory range starting at <code>0xFFFFxxxx</code>.</p>"},{"location":"sw/#communication-uart","title":"Communication (UART)","text":"Address Register Name Perms Description <code>0xFFFF0000</code> UART_RX_VALID RO Receive Status. Data is valid to read from <code>UART_RX</code> only when the LSB (Least Significant Bit) of this register is set to 1. <code>0xFFFF0004</code> UART_RX RO Receive Data. Reads input from the keyboard. Only the LSByte (lowest 8 bits) contains valid data. <code>0xFFFF0008</code> UART_TX_READY RO Transmit Status. Data is safe to write to <code>UART_TX</code> only when the LSB of this register is set to 1. <code>0xFFFF000C</code> UART_TX WO Transmit Data. Sends output to the display/console. Only the LSByte is writeable."},{"location":"sw/#on-board-io-gpio","title":"On-Board I/O (GPIO)","text":"Address Register Name Perms Description <code>0xFFFF0060</code> LED WO LED control register <code>0xFFFF0064</code> DIP RO DIP switch input register <code>0xFFFF0068</code> PB RO Push button input register <code>0xFFFF0080</code> SEVENSEG WO 7-segment display output register <p>Register Details</p> <code>LED -- 0xFFFF0060 (WO)</code> <p>The lower 8 bits are user-writeable. The upper bits are hardwired as follows:</p> <ul> <li>[7:0] user writeable,</li> <li>[8] divided clock,</li> <li>[15:9] program counter <code>[8:2]</code>.</li> </ul> <code>DIP -- 0xFFFF0064 (RO)</code> <p>Reads the state of the 16 on-board switches, covering switch range SW15\u2013SW0.</p> <code>PB -- 0xFFFF0068 (RO)</code> <p>Only the lowest 3 bits are valid.</p> <ul> <li>[2] BTNR (Right),</li> <li>[1] BTNC (Center),</li> <li>[0] BTNL (Left).</li> </ul> <p>The remaining buttons are hardwired: BTND resets the system, while BTNU pauses execution.</p> <code>SEVENSEG -- 0xFFFF0080 (WO)</code> <p>Writes an 8-digit hexadecimal number to the 7-segment display.</p>"},{"location":"sw/#sensor-display-modules","title":"Sensor &amp; Display Modules","text":"Address Register Name Perms Description <code>0xFFFF0020</code> OLED_COL WO Sets the OLED pixel column index (0 \u2013 95). <code>0xFFFF0024</code> OLED_ROW WO Sets the OLED pixel row index (0 \u2013 63). <code>0xFFFF0028</code> OLED_DATA WO Writes data to the pixel. Format depends on <code>OLED_CTRL</code>. <code>0xFFFF002C</code> OLED_CTRL WO Controls OLED data format and operation modes. <code>0xFFFF0040</code> ACCEL_DATA RO Reads accelerometer data (refer to peripherals documentation for format). <code>0xFFFF0044</code> ACCEL_DREADY RO Data Ready. LSB is set when a new reading is available."},{"location":"sw/#system-counters","title":"System Counters","text":"Address Register Name Perms Description <code>0xFFFF00A0</code> CYCLECOUNT RO Returns the number of clock cycles elapsed since system reset."},{"location":"sw/#toolchain-setup","title":"Toolchain Setup","text":"<p>I used the RISC-V GNU Toolchain to compile C code into machine code (hex files) and then load them into the Mach-V processor's IROM (<code>AA_IROM.mem</code>) and DMEM (<code>AA_DMEM.mem</code>).</p>"},{"location":"sw/#install-toolchain","title":"Install Toolchain","text":"<p>The toolchain that I used is pre-built and can be found on GitHub. I chose the <code>rv32i-131023</code> version. The installation guide is also available on the repository.</p>"},{"location":"sw/#build-configuration","title":"Build Configuration","text":"<p>To compile C code into hex files for IROM and DMEM, I used three files: <code>Makefile</code>, <code>ld.script</code> and <code>crt.s</code>. For every C program that is newly written, these three files need to be added and modified accordingly.</p>"},{"location":"sw/#makefile","title":"<code>Makefile</code>","text":"<p><code>Makefile</code> defines the rules for the <code>make</code> command to work. Make sure the <code>GCC_DIR</code> is correct and feel free to change the <code>CFLAGS</code> as you wish (like changing the Optimization flag from <code>-O2</code> to <code>-O3</code> etc).</p> <p>Info</p> <p>You can get a template from any one of the application, but I recommend the <code>sw/calculator/Makefile</code>.</p>"},{"location":"sw/#ldscript","title":"<code>ld.script</code>","text":"<p><code>ld.script</code> first specifies the size left for IROM and DMEM. In the Mach-V processor,</p> <ul> <li><code>ROM</code> stands for IROM, its <code>ORIGIN</code> is <code>0x00400000</code>, its <code>LENGTH</code> depends on the size of the <code>code.hex</code> generated.</li> <li><code>RAM</code> stands for DMEM, its <code>ORIGIN</code> is <code>0x10010000</code>, its <code>LENGTH</code> depends on the size of the <code>data.hex</code> generated.</li> </ul> <p>Secondly, it specifies which section in the compiled program goes to which memory region. This determines which part of the program is stored in IROM and which part is stored in DMEM. For example,</p> <ul> <li>the <code>.rodata</code> and <code>.data</code> sections are dumped into DMEM</li> <li>the <code>.text</code> section is dumped into IROM.</li> </ul>"},{"location":"sw/#crts","title":"<code>crt.s</code>","text":"<p>The <code>crt.s</code> file is the entry point of the software. It sets up the execution environment before handing control to the C <code>main()</code> function.</p> <p>For each new application, the <code>li sp, &lt;address&gt;</code> instruction needs to be modified to set the stack pointer (<code>sp</code>) to the top of DMEM. The stack grows downwards from high memory to low memory. Thus you should set the stack pointer to the very end of your available DMEM.</p> \\[ \\text{Initial SP} = \\text{DMEM_BASE} + \\text{DMEM_SIZE} \\] <p>For example, if your DMEM size is 7KB (the <code>sw/coremark</code> example), and the Mach-V processor's DMEM base address is <code>0x10010000</code>, then the initial stack pointer should be set to:</p> <pre><code>li sp, 0x10011C00  # 0x10010000 + 7 * 1024\n</code></pre>"},{"location":"sw/#compile-and-load","title":"Compile and Load","text":"<p>After setting up the three files above, you can simply run the <code>make</code> command in the terminal while being in the application's directory. If everything is set up correctly, two hex files named <code>code.hex</code> and <code>data.hex</code> will be generated. Copy and paste the contents of <code>code.hex</code> into <code>AA_IROM.mem</code> and <code>data.hex</code> into <code>AA_DMEM.mem</code> in the Vivado project to load the program into the Mach-V processor.</p> <p>To clean up the generated files, you can run <code>make clean</code>.</p> <p>Success</p> <p>Now you are ready to write, compile, and run your software on the Mach-V processor! Feel free to move on to explore the existing software applications in the <code>sw/</code> directory.</p>"},{"location":"sw/benchmark/","title":"CoreMark Benchmark","text":"<p>The CoreMark benchmark is used to evaluate the performance of the Mach-V processor. It measures the CPU's ability to handle list processing, matrix manipulation, and state machine execution.</p>"},{"location":"sw/benchmark/#source-code-organization","title":"Source Code Organization","text":"<p>The CoreMark source code and build scripts are located in the <code>sw/coremark/</code> directory.</p>"},{"location":"sw/benchmark/#porting-implementation","title":"Porting Implementation","text":"<p>The CoreMark port for Mach-V is based on the barebones implementation. To adapt it for the Mach-V memory map, modifications are required in <code>sw/coremark/barebones/core_portme.c</code> and <code>sw/coremark/barebones/ee_printf.c</code>.</p>"},{"location":"sw/benchmark/#system-timer","title":"System Timer","text":"<p>CoreMark requires a method to measure time to calculate the performance score. In <code>core_portme.c</code>, the <code>barebones_clock()</code> function is modified to read the Mach-V <code>CYCLECOUNT</code> system counter.</p> <p>Modification: Update <code>hardwareCounterAddr</code> to point to the Mach-V system counter address (<code>0xFFFF00A0</code>).</p> <pre><code>CORETIMETYPE barebones_clock() {\n    // Pointer to the Mach-V System Counter (CYCLECOUNT)\n    volatile unsigned int* hardwareCounterAddr = (unsigned int*)0xffff00a0;\n\n    unsigned int hardwareCounter;\n\n    // Read hardwareCounter (Execution Cycle)\n    hardwareCounter = *hardwareCounterAddr;\n\n    return (CORETIMETYPE)hardwareCounter;\n}\n</code></pre>"},{"location":"sw/benchmark/#uart-output","title":"UART Output","text":"<p>To output the benchmark results to the console, the UART transmission function must be mapped to the correct MMIO addresses.</p> <p>Modification: In <code>ee_printf.c</code>, update the pointers in <code>uart_send_char()</code> to match the Mach-V UART peripheral addresses. The relevant addresses are introduced in System Memory Map.</p> <pre><code>void uart_send_char(char c) {\n    volatile unsigned int *UART_TX_READY_ADDR = (unsigned int*)0xFFFF0008;\n    volatile unsigned char *UART_TX_ADDR = (unsigned char*)0xFFFF000C;\n\n    // Wait until UART is ready (LSB == 1 indicates ready)\n    while ((*UART_TX_READY_ADDR &amp; 0x1) == 0);\n\n    // Write character to the transmission buffer\n    *UART_TX_ADDR = c;\n\n    // Optional: Wait for transmission completion\n    while ((*UART_TX_READY_ADDR &amp; 0x1) == 0);\n}\n</code></pre>"},{"location":"sw/benchmark/#build-configuration","title":"Build Configuration","text":""},{"location":"sw/benchmark/#setting-clock-frequency","title":"Setting Clock Frequency","text":"<p>To ensure the CoreMark score (Iterations/Sec) is calculated correctly, the build script must know the target processor frequency.</p> <p>Modify the <code>Makefile</code> under <code>sw/coremark</code> to set the <code>CLOCKS_PER_SEC</code> flag. This value must match the frequency of the Mach-V processor. For example, for a design running at 50 MHz:</p> <pre><code>CLOCKS_PER_SEC = 50000000\n</code></pre> <p>Warning</p> <p>If <code>CLOCKS_PER_SEC</code> does not match the actual hardware clock frequency, the reported CoreMark/MHz score will be mathematically incorrect.</p> <p>Ready to Run</p> <p>With the porting layer configured and the frequency set, the CoreMark benchmark is ready to run on Mach-V!</p>"},{"location":"sw/resources/","title":"Resoures &amp; Utilities","text":"<p>This section contains utility guides and extra information regarding the Mach-V software stack.</p>"},{"location":"sw/resources/#offline-access","title":"Offline Access","text":"<p>This documentation supports exporting the entire site as a single, consolidated PDF for offline reading. This is powered by the <code>mkdocs-print-site-plugin</code>.</p>"},{"location":"sw/resources/#export-to-pdf","title":"Export to PDF","text":"<p>Currently, there is no direct download button in the navigation bar. You can generate the PDF manually by following these steps:</p> <ol> <li>Access the Print View: Navigate to the consolidated print view by appending <code>print_page/</code> to the base URL of the documentation. For example, go to <code>https://mendax1234.github.io/Mach-V/print_page/</code>.</li> <li>Print to PDF: Once the page loads (it may take a moment to render all chapters):<ol> <li>Open your browser's print dialog (<code>Ctrl + P</code> on Windows/Linux or <code>Cmd + P</code> on macOS).</li> <li>Set the Destination to \"Save as PDF\".</li> <li>Click Save.</li> </ol> </li> </ol> <p>Formatting</p> <p>For the best layout, ensure Background graphics is checked in your browser's print settings to preserve syntax highlighting and admonition colors.</p>"},{"location":"sw/resources/#useful-links","title":"Useful Links","text":"<p>The success of Mach-V cannot be achieved without the help of many open-source projects and resources. Here are some useful links that you may find helpful when working with Mach-V:</p> <ul> <li> <p> CoreMark Benchmark</p> <p>Official CoreMark benchmark by EEMBC, widely used to evaluate embedded processor performance.</p> <p> Visit EEMBC</p> </li> <li> <p> CoreMark on Bare-Metal Systems</p> <p>CoreMark running on bare-bone RISC-V systems, including build scripts and platform-specific adaptations.</p> <p> View on GitHub</p> </li> <li> <p> Pre-built RISC-V GNU Toolchain</p> <p>Pre-compiled RISC-V GCC toolchain for rapid development without building from source.</p> <p> Download Toolchain</p> </li> </ul>"},{"location":"sw/uart_calculator/","title":"UART Calculator","text":"<p>This is a simple calculator program that is used to test the basic functionality of the Mach-V processor. It contains all the basic instructiosn from RISC-V I and M extensions, and performs arithmetic operations based on user input via UART.</p>"},{"location":"sw/uart_calculator/#source-code-organization","title":"Source Code Organization","text":"<p>The source code for the UART Calculator is located in the <code>sw/uart_calculator/</code> directory. The main source file is <code>uart_calculator.c</code>, which contains the implementation of the calculator logic and UART communication.</p>"},{"location":"sw/uart_calculator/#porting-implementation","title":"Porting Implementation","text":""},{"location":"sw/uart_calculator/#uart-output","title":"UART Output","text":"<p>As the calculator uses UART to communicate with the Mach-V processor, if the MMIO addresses are changed, the code in <code>uart_calculator.c</code> must be updated accordingly. The MMIO definitions are located at the top of the <code>uart_calculator.c</code> file,</p> <pre><code>#define MMIO_BASE 0xFFFF0000\n#define UART_RX_VALID_OFF 0x00\n#define UART_RX_DATA_OFF 0x04\n#define UART_TX_READY_OFF 0x08\n#define UART_TX_DATA_OFF 0x0C\n#define SEVENSEG_OFF 0x80\n</code></pre> <p>Info</p> <p>If you are using different MMIO addresses for UART or other peripherals, make sure to update these definitions accordingly.</p>"},{"location":"sw/uart_calculator/#dmem-initialization","title":"DMEM Initialization","text":"<p>The application pre-loads data into Data Memory (DMEM) to test Load/Store instructions. This is handled via initialized global arrays in C, which the linker places in the <code>.data</code> section.</p> <pre><code>// Pre-loaded test patterns for Load operations\nuint32_t test_data[4] = {\n    0x12345678,\n    0x9ABCDEF0,\n    0xAABBCCDD,\n    0xEEFF0011};\n</code></pre>"},{"location":"sw/uart_calculator/#build-configuration","title":"Build Configuration","text":"<p>There is nothing much to customize or change in the <code>Makefile</code>, <code>ld.script</code> and <code>crt.s</code> files for this application. This is also why this application can be regarded as a template for other new applications.</p>"},{"location":"sw/uart_calculator/#application-usage","title":"Application Usage","text":"<p>The calculator operates using a strictly defined 9-byte communication protocol over UART.</p>"},{"location":"sw/uart_calculator/#communication-protocol","title":"Communication Protocol","text":"<p>For every operation, the user must send exactly 9 bytes to the processor:</p> <ol> <li>Command 1(1 Byte): An ASCII character selecting the operation (see table below).</li> <li>Operand 1(4 Bytes): The first 32-bit argument, sent Big-Endian (MSB first).</li> <li>Operand 2(4 Bytes): The second 32-bit argument, sent Big-Endian (MSB first).</li> </ol> <p>Output: The result of the operation is written to the 7-segment Display MMIO address.</p>"},{"location":"sw/uart_calculator/#command-reference","title":"Command Reference","text":"Category Command ASCII Operation Description Arithmetic ADD a op1 + op2 32-bit Addition SUB s op1 - op2 32-bit Subtraction Logical AND c op1 &amp; op2 Bitwise AND OR o op1 | op2 Bitwise OR XOR x op1 ^ op2 Bitwise XOR Shift SLL L op1 &lt;&lt; op2 Shift Left Logical SRL R op1 &gt;&gt; op2 Shift Right Logical SRA A op1 &gt;&gt; op2 Shift Right Arithmetic (sign-extended) Comparison SLT l op1 &lt; op2 Set if Less Than (Signed) SLTU u op1 &lt; op2 Set if Less Than (Unsigned) Multiply / Div MUL m op1 * op2 Low 32 bits of product MULH H op1 * op2 High 32 bits (Signed) MULHU h op1 * op2 High 32 bits (Unsigned) DIV d op1 / op2 Signed Division DIVU D op1 / op2 Unsigned Division REM r op1 % op2 Signed Remainder REMU M op1 % op2 Unsigned Remainder Memory Access LOAD 1..4 Mem[op1] Reads from <code>test_data</code>. 1=LB, 2=LBU, 3=LH, 4=LHU STORE 5..6 Mem[op1] = op2 Writes to <code>scratch_mem</code>. 5=SB, 6=SH"},{"location":"uarch/","title":"Microarchitecture","text":"<p>Here is the performance scaling of the Mach-V core running the CoreMark benchmark.</p> <p> </p> <p>The microarchitecture of Mach-V is shown in the figure below:</p> Mach-V Version 1Mach-V Version 2 <p></p> <p>Mach-V Microarchitecture - Version 1</p> <p></p> <p>Mach-V Microarchitecture - Version 2</p>"},{"location":"uarch/mul-div/","title":"Multiply &amp; Divide Unit","text":"<p>In this version of the Mach-V processor, the multiply and divide unit is incorporated into one file called <code>MCycle.v</code>. The whole idea of the <code>MCycle</code> module is that, while it is doing the computation, the <code>Busy</code> signal (output) will be triggered high and this signal will be used to stall the other relevant pipeline registers so that no new instructions are fetched until the multiplication/division is complete.</p> <p>This module is implemented using the mealy state machine.</p>"},{"location":"uarch/mul-div/#state-machine-control","title":"State Machine Control","text":""},{"location":"uarch/mul-div/#implementation-details","title":"Implementation Details","text":"<p>I have tried two implementations for the <code>MCycle</code> module:</p> <ul> <li> <p> Native Design</p> <p>Implement the multiply and divide unit by \"hand-typped\" Verilog code.</p> <p> View Documentation</p> </li> <li> <p> Using IP Cores</p> <p>Use Xilinx IP cores to implement the multiply and divide unit.</p> <p> View Documentation</p> </li> </ul>"},{"location":"uarch/mul-div/native-design/","title":"Native Design of Multiply &amp; Divide Unit","text":"<p>This is a follow-up from CG3207 Assignment 3. More specifically, it is my try to finish the first bullet point in the Task 3 of this assignment.</p>"},{"location":"uarch/mul-div/native-design/#multiply-unit","title":"Multiply Unit","text":"<p>For the multiply unit, the idea is to \"unroll\" the loop. For the 32-bit multiplication, instead of using 32 cycles to compute the result by shifting 1 bit a time, I generate the partial products for every 8 bits of the multiplier in parallel. So, the temporal product here will be \\(32+8=40\\) bits wide.</p> <pre><code>module Multiplier32x8 (\n    input  [31:0] A,       // The 32-bit full operand\n    input  [ 7:0] B,       // The 8-bit slice\n    output [39:0] Product  // Result (32 + 8 = 40 bits max)\n);\n\n    // // Generate Partial Products (Shift A based on bit position of B)\n    wire [39:0] pp0 = B[0] ? {8'b0, A} : 40'b0;\n    wire [39:0] pp1 = B[1] ? {7'b0, A, 1'b0} : 40'b0;\n    wire [39:0] pp2 = B[2] ? {6'b0, A, 2'b0} : 40'b0;\n    wire [39:0] pp3 = B[3] ? {5'b0, A, 3'b0} : 40'b0;\n    wire [39:0] pp4 = B[4] ? {4'b0, A, 4'b0} : 40'b0;\n    wire [39:0] pp5 = B[5] ? {3'b0, A, 5'b0} : 40'b0;\n    wire [39:0] pp6 = B[6] ? {2'b0, A, 6'b0} : 40'b0;\n    wire [39:0] pp7 = B[7] ? {1'b0, A, 7'b0} : 40'b0;\n\n    // Sum them up (Tree adder is faster, but this simple chain works also)\n    assign Product = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n</code></pre> <p>In this module, the input <code>A</code> is the full 32-bit multiplicand, while <code>B</code> is an 8-bit slice of the multiplier. The output <code>Product</code> is the 40-bit partial product. For the sliced version of the multiplier, it can be implemented as follows in the state machine control:</p> <pre><code>case (count[1:0])\n    2'b00: current_byte_op2 = abs_op2[7:0];\n    2'b01: current_byte_op2 = abs_op2[15:8];\n    2'b10: current_byte_op2 = abs_op2[23:16];\n    2'b11: current_byte_op2 = abs_op2[31:24];\nendcase\n</code></pre> <p>The final product is then obtained by summing up the 4 partial products with appropriate shifts, which can be implemented as follows:</p> <pre><code>case (count)\n    1: mult_acc = mult_acc + partial_product_out;\n    2: mult_acc = mult_acc + (partial_product_out &lt;&lt; 8);\n    3: mult_acc = mult_acc + (partial_product_out &lt;&lt; 16);\n    4: mult_acc = mult_acc + (partial_product_out &lt;&lt; 24);\nendcase\n</code></pre> <p>And lastly, this module is instantiated in the <code>MCycle</code> module as follows:</p> <pre><code>Multiplier32x8 mul_unit (\n    .A      (abs_op1),\n    .B      (current_byte_op2),\n    .Product(partial_product_out)\n);\n</code></pre> Tip <p>This technique can indeed be implementated using <code>for</code> loop in Verilog as follows:</p> <pre><code>module Multiplier32x8 (\n    input  [31:0] A,       // The 32-bit full operand\n    input  [ 7:0] B,       // The 8-bit slice\n    output [39:0] Product  // Result (32 + 8 = 40 bits max)\n);\n\n    // // Generate Partial Products (Shift A based on bit position of B)\n    wire [39:0] pp0 = B[0] ? {8'b0, A} : 40'b0;\n    wire [39:0] pp1 = B[1] ? {7'b0, A, 1'b0} : 40'b0;\n    wire [39:0] pp2 = B[2] ? {6'b0, A, 2'b0} : 40'b0;\n    wire [39:0] pp3 = B[3] ? {5'b0, A, 3'b0} : 40'b0;\n    wire [39:0] pp4 = B[4] ? {4'b0, A, 4'b0} : 40'b0;\n    wire [39:0] pp5 = B[5] ? {3'b0, A, 5'b0} : 40'b0;\n    wire [39:0] pp6 = B[6] ? {2'b0, A, 6'b0} : 40'b0;\n    wire [39:0] pp7 = B[7] ? {1'b0, A, 7'b0} : 40'b0;\n\n    // Sum them up (Tree adder is faster, but this simple chain works also)\n    assign Product = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n</code></pre> <p>This is totally valid. However, the smart synthesizer will generate the same hardware for both implementations.</p> <p>Warning</p> <p>The 8 bits design will still use more hardware than I thought, which will give around 13ns propagation delay. This will limit the Mach-V clock frequency to 50MHz max if the clock wizard is not used!</p>"},{"location":"uarch/mul-div/native-design/#divide-unit","title":"Divide Unit","text":"<p>Similarly, I did the unrolling for the divider unit as well. So, instead of getting at most 1 bit of quotient and remainder per cycle. Now, I can get at most 8 bits of quotient and remainder per cycle. This divider unit is implemented using the <code>for</code> loop in Verilog as follows:</p> <pre><code>module DivSlice8 #(\n    parameter width = 32\n) (\n    input      [2*width-1:0] rem_in,   // Current Remainder\n    input      [2*width-1:0] div_in,   // Current Divisor\n    input      [  width-1:0] quot_in,  // Current Quotient (LSW of buffer)\n    output reg [2*width-1:0] rem_out,  // Next Remainder\n    output reg [2*width-1:0] div_out,  // Next Divisor\n    output reg [  width-1:0] quot_out  // Next Quotient\n);\n\n    // Temporary variable for subtraction\n    integer             i;\n    reg     [2*width:0] diff_ext;\n\n    always @(*) begin\n        // Initialize temporary variables with inputs\n        rem_out = rem_in;\n        div_out = div_in;\n        quot_out = quot_in;\n\n        // Perform 8 iterations of division logic (Combinational Loop)\n        for (i = 0; i &lt; 8; i = i + 1) begin\n            // 1. Subtract: Remainder - Divisor\n            diff_ext = {1'b0, rem_out} + {1'b0, ~div_out} + 1'b1;\n\n            // 2. Check Sign\n            if (diff_ext[2*width] == 1'b1) begin\n                // Result Positive: Update Remainder, Shift 1 into Quotient\n                rem_out = diff_ext[2*width-1:0];\n                quot_out = {quot_out[width-2:0], 1'b1};\n            end else begin\n                // Result Negative: Keep Remainder, Shift 0 into Quotient\n                quot_out = {quot_out[width-2:0], 1'b0};\n            end\n\n            // 3. Shift Divisor Right for the next step\n            div_out = {1'b0, div_out[2*width-1:1]};\n        end\n    end\nendmodule\n</code></pre> <p>To use the result from the divider unit, the state machine control can just be modified by updating the current remainder and quotient to be the result from the divider unit after each cycle:</p> <pre><code>if (count &gt; 0) begin\n    rem = next_rem;\n    div = next_div;\n    div_result_buf[width-1:0] = next_quot;\n    div_result_buf[2*width-1:width] = rem[width-1:0];\nend\n</code></pre> <p>And finally, this divider unit is implemented as follows in the <code>MCycle</code> module:</p> <pre><code>DivSlice8 div_unit (\n    .rem_in  (rem),\n    .div_in  (div),\n    .quot_in (div_result_buf[width-1:0]),\n    .rem_out (next_rem),\n    .div_out (next_div),\n    .quot_out(next_quot)\n);\n</code></pre> <p>Warning</p> <p>Using the unrolling techniue in the divider unit here will use a lot of hardware! iirc, the propagation delay is around 66ns for this design! Given that high propagation delay, it is impossible to use this design on Mach-V. So, I moved on to the next section, which is to use Xilinix IP core for the multiply and divide unit.</p>"},{"location":"uarch/mul-div/vendor-ip/","title":"AMD IP Design","text":"<p>As mentioned in the previous documentation, if I only use the unrolling technique, it is impossible to reach higher frequency while keeping the cycles for multiplication and division low. Therefore, I decided to use the AMD IP cores (Multiplier and Divider) to implement the multiply and divide unit.</p>"},{"location":"uarch/mul-div/vendor-ip/#generate-the-ip-core","title":"Generate the IP Core","text":""},{"location":"uarch/mul-div/vendor-ip/#multiplier-ip","title":"Multiplier IP","text":"<p>The multiplier IP core comes from AMD and can be used in Vivado directly.</p> <p>To use the IP in Vivado, click the \"IP Catalog\" on the left flow navigator. Then, search for \"multiplier\". Click the \"Multiplier\" (not \"Complex Multiplier\"). And the configure the IP to use the following settings:</p> <ol> <li>In the \"Basic\" tab:<ul> <li>Set Multiplier Type to \"Parallel Multiplier\"</li> <li>Set <code>A</code> and <code>B</code> to be \"unsigned\" and \"32-bit\" wide</li> <li>Set Multiplier Construction to \"Use Mults\"</li> <li>Set the Optimization Options to \"Speed Optimized\"</li> </ul> </li> <li>In the \"Output and Control\" tab<ul> <li>Make sure the <code>P</code> (output) is 64-bit wide.</li> <li>Set the Pipeline Stages to 4.</li> </ul> </li> </ol> <p>Tip</p> <p>With the above settings, the multiplier IP core will take 5 cycles to complete and the propagation is safer for the processor to reach 100MHz and higher.</p>"},{"location":"uarch/mul-div/vendor-ip/#divider-ip","title":"Divider IP","text":"<p>Simiarly, the divider IP core also comes from AMD and can be used in Vivado directly.</p> <p>Follow the similar steps as the multiplier IP core, but configure the divider using the following settings:</p> <ol> <li>In the \"Channel Settings\" tab:<ul> <li>Set Algorithm type of \"Radix 2\" and Operand sign to \"unsigned\".</li> <li>Change dividend and divisor width to \"32\".</li> <li>Set the Remainder Type to be \"Remainder\" and fractional width to be \"32\".</li> </ul> </li> <li>In the \"Options\" tab:<ul> <li>Set Clocks per Division to be \"1\".</li> <li>Set the flow control under AXI4-Stream settings to \"Blocking\".</li> <li>Set the optimize goal under AXI4-Stream settings to \"Performance\".</li> </ul> </li> </ol> <p>Tip</p> <p>With the above settings, the divider IP core will take 32 cycles to complete and the propagation is safer for the processor to reach 100MHz and higher.</p>"},{"location":"uarch/mul-div/vendor-ip/#use-ip-core","title":"Use IP Core","text":"<p>To use the two IP cores that we have generated above, we just need to know the inputs and outputs of each IP core and then instantiate them in our <code>MCycle.v</code> to replace the multiple unit and the divide unit that we have implemented manually in the previous section.</p> <pre><code>// Multiplier IP: 32x32 Unsigned -&gt; 64-bit Product\nmult_gen_0 my_multiplier (\n    .CLK(CLK),\n    .A  (abs_op1),\n    .B  (abs_op2),\n    .P  (mul_dout)\n);\n\n// Divider IP: 32/32 Unsigned -&gt; 32 Quot, 32 Rem\ndiv_gen_0 my_divider (\n    .aclk                  (CLK),\n    .s_axis_divisor_tvalid (div_in_valid),\n    .s_axis_divisor_tdata  (abs_op2),\n    .s_axis_dividend_tvalid(div_in_valid),\n    .s_axis_dividend_tdata (abs_op1),\n    .m_axis_dout_tvalid    (div_out_valid),\n    .m_axis_dout_tdata     (div_dout)\n);\n</code></pre>"}]}