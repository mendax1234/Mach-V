{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hydra-V Processor","text":"<p>Welcome to the documentation for Hydra-V, a custom RISC-V processor implementation targeting the Nexys 4 DDR FPGA.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>ISA: RISC-V RV32I Base Integer Instruction Set</li> <li>Pipeline: 5-Stage Classic (Fetch, Decode, Execute, Memory, Writeback)</li> <li>Hazard Handling: Full Forwarding Unit + Stall Logic</li> <li>Peripherals: UART, GPIO, Seven-Segment Display</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the User Guide to run your first program, or view the Verification section to run the testbench.</p>"},{"location":"sim/simulation/","title":"Verification &amp; Simulation","text":"<p>This section outlines the verification strategy for the Hydra-V processor, including unit testing and full system simulation.</p>"},{"location":"sim/simulation/#simulation-directory-structure","title":"Simulation Directory Structure","text":"<p>The <code>sim/</code> directory contains all testbench and verification artifacts:</p> <ul> <li><code>sim/tb/</code>: Verilog testbenches for individual modules (ALU, RegFile) and the top-level core.</li> <li><code>sim/hex/</code>: Pre-compiled hexadecimal files (machine code) loaded into instruction memory for simulation.</li> </ul>"},{"location":"sim/simulation/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following tools installed:</p> <ol> <li>Xilinx Vivado (for Behavioral Simulation)</li> <li>Verilator (Optional, for faster C++ based simulation)</li> <li>GTKWave (for viewing waveform dumps outside Vivado)</li> </ol>"},{"location":"sim/simulation/#running-simulations","title":"Running Simulations","text":""},{"location":"sim/simulation/#unit-level-testing","title":"Unit Level Testing","text":"<p>Unit tests verify specific components before integration.</p> <pre><code># Example: Running the ALU testbench\ncd sim/tb\nxvlog alu.v alu_tb.v\nxelab -debug typical alu_tb -s alu_sim\nxsim alu_sim -R\n</code></pre>"},{"location":"sim/simulation/#top-level-system-test","title":"Top Level System Test","text":"<p>To verify the full processor pipeline:</p> <ol> <li>Load a program hex file into <code>sim/hex/main.hex</code>.</li> <li>Run the top-level testbench <code>tb_core.v</code>.</li> <li>Observe the <code>d_mem</code> and register file changes.</li> </ol> <p>Debugging with Waveforms</p> <p>If the processor stalls, check the stall_signal and flush lines in the Waveform viewer. A permanent high signal usually indicates a lockup in the Hazard Unit.</p>"},{"location":"sw/","title":"Software Development Guide","text":"<p>This guide explains how to write, compile, and run different software on the Hydra-V processor.</p>"},{"location":"sw/#software-directory-structure","title":"Software Directory Structure","text":"<p>The <code>sw/</code> directory is organized by application. For example:</p> <ul> <li><code>sw/coremark/</code> contais the CoreMark benchmark source code and build scripts.</li> </ul>"},{"location":"sw/#system-memory-map","title":"System Memory Map","text":"<p>Followed by the convention set in NUS CG3207, the Hydra-V processor uses a memory-mapped I/O architecture. The address space is divided into Instruction Memory, Data Memory, and Peripheral (MMIO) regions.</p> <p>Configuration Source</p> <p>The memory capacities defined below are determined by parameters in <code>Wrapper.v</code>. For example, <pre><code>localparam IROM_DEPTH_BITS = 15;     // for 2^15 words = 32KB\nlocalparam DMEM_DEPTH_BITS = 14;     // for 2^14 words = 16KB\nlocalparam MMIO_DEPTH_BITS = 8;      // for 2^8 words = 1KB\n</code></pre></p> <p>If you modify these parameters in <code>Wrapper.v</code>, you must update your linker script and stack initialization accordingly.</p>"},{"location":"sw/#main-memory","title":"Main Memory","text":"Address Range Name Permissions Description <code>0x00400000 \u2013 0x00407FFF</code> IROM (Instruction Memory) RO (Read-Only) Capacity: 8,192 words (32 KB). Based on <code>IROM_DEPTH_BITS = 15</code>. <code>0x10010000 \u2013 0x10013FFF</code> DMEM (Data Memory) RW (Read-Write) Capacity: 4,096 words (16 KB). Used for storing constants and variables. Based on <code>DMEM_DEPTH_BITS = 14</code>. <p>Addressing Constraints</p> <p>Accesses must be aligned to 4-byte boundaries.</p>"},{"location":"sw/#memory-mapped-peripherals-mmio","title":"Memory-Mapped Peripherals (MMIO)","text":"<p>All peripherals are mapped to the upper memory range starting at <code>0xFFFFxxxx</code>.</p>"},{"location":"sw/#communication-uart","title":"Communication (UART)","text":"Address Register Name Perms Description <code>0xFFFF0000</code> UART_RX_VALID RO Receive Status. Data is valid to read from <code>UART_RX</code> only when the LSB (Least Significant Bit) of this register is set to 1. <code>0xFFFF0004</code> UART_RX RO Receive Data. Reads input from the keyboard. Only the LSByte (lowest 8 bits) contains valid data. <code>0xFFFF0008</code> UART_TX_READY RO Transmit Status. Data is safe to write to <code>UART_TX</code> only when the LSB of this register is set to 1. <code>0xFFFF000C</code> UART_TX WO Transmit Data. Sends output to the display/console. Only the LSByte is writeable."},{"location":"sw/#on-board-io-gpio","title":"On-Board I/O (GPIO)","text":"Address Register Name Perms Description <code>0xFFFF0060</code> LED WO LED control register <code>0xFFFF0064</code> DIP RO DIP switch input register <code>0xFFFF0068</code> PB RO Push button input register <code>0xFFFF0080</code> SEVENSEG WO 7-segment display output register <p>Register Details</p> <code>LED -- 0xFFFF0060 (WO)</code> <p>The lower 8 bits are user-writeable. The upper bits are hardwired as follows:</p> <ul> <li>[7:0] user writeable,</li> <li>[8] divided clock,</li> <li>[15:9] program counter <code>[8:2]</code>.</li> </ul> <code>DIP -- 0xFFFF0064 (RO)</code> <p>Reads the state of the 16 on-board switches, covering switch range SW15\u2013SW0.</p> <code>PB -- 0xFFFF0068 (RO)</code> <p>Only the lowest 3 bits are valid.</p> <ul> <li>[2] BTNR (Right),</li> <li>[1] BTNC (Center),</li> <li>[0] BTNL (Left).</li> </ul> <p>The remaining buttons are hardwired: BTND resets the system, while BTNU pauses execution.</p> <code>SEVENSEG -- 0xFFFF0080 (WO)</code> <p>Writes an 8-digit hexadecimal number to the 7-segment display.</p>"},{"location":"sw/#sensor-display-modules","title":"Sensor &amp; Display Modules","text":"Address Register Name Perms Description <code>0xFFFF0020</code> OLED_COL WO Sets the OLED pixel column index (0 \u2013 95). <code>0xFFFF0024</code> OLED_ROW WO Sets the OLED pixel row index (0 \u2013 63). <code>0xFFFF0028</code> OLED_DATA WO Writes data to the pixel. Format depends on <code>OLED_CTRL</code>. <code>0xFFFF002C</code> OLED_CTRL WO Controls OLED data format and operation modes. <code>0xFFFF0040</code> ACCEL_DATA RO Reads accelerometer data (refer to peripherals documentation for format). <code>0xFFFF0044</code> ACCEL_DREADY RO Data Ready. LSB is set when a new reading is available."},{"location":"sw/#system-counters","title":"System Counters","text":"Address Register Name Perms Description <code>0xFFFF00A0</code> CYCLECOUNT RO Returns the number of clock cycles elapsed since system reset."},{"location":"sw/#toolchain-setup","title":"Toolchain Setup","text":"<p>I used the RISC-V GNU Toolchain to compile C code into machine code (hex files) and then load them into the Hydra-V processor's IROM (<code>AA_IROM.mem</code>) and DMEM (<code>AA_DMEM.mem</code>).</p>"},{"location":"sw/#install-toolchain","title":"Install Toolchain","text":"<p>The toolchain that I used is pre-built and can be found on GitHub. I chose the <code>rv32i-131023</code> version. The installation guide is also available on the repository.</p>"},{"location":"sw/#build-configuration","title":"Build Configuration","text":"<p>To compile C code into hex files for IROM and DMEM, I used three files: <code>Makefile</code>, <code>ld.script</code> and <code>crt.s</code>. For every C program that is newly written, these three files need to be added and modified accordingly.</p>"},{"location":"sw/#makefile","title":"<code>Makefile</code>","text":"<p><code>Makefile</code> defines the rules for the <code>make</code> command to work. Make sure the <code>GCC_DIR</code> is correct and feel free to change the <code>CFLAGS</code> as you wish (like changing the Optimization flag from <code>-O2</code> to <code>-O3</code> etc).</p> <p>Info</p> <p>You can get a template from any one of the application, but I recommend the <code>sw/calculator/Makefile</code>.</p>"},{"location":"sw/#ldscript","title":"<code>ld.script</code>","text":"<p><code>ld.script</code> first specifies the size left for IROM and DMEM. In the Hydra-V processor,</p> <ul> <li><code>ROM</code> stands for IROM, its <code>ORIGIN</code> is <code>0x00400000</code>, its <code>LENGTH</code> depends on the size of the <code>code.hex</code> generated.</li> <li><code>RAM</code> stands for DMEM, its <code>ORIGIN</code> is <code>0x10010000</code>, its <code>LENGTH</code> depends on the size of the <code>data.hex</code> generated.</li> </ul> <p>Secondly, it specifies which section in the compiled program goes to which memory region. This determines which part of the program is stored in IROM and which part is stored in DMEM. For example,</p> <ul> <li>the <code>.rodata</code> and <code>.data</code> sections are dumped into DMEM</li> <li>the <code>.text</code> section is dumped into IROM.</li> </ul>"},{"location":"sw/#crts","title":"<code>crt.s</code>","text":"<p>The <code>crt.s</code> file is the entry point of the software. It sets up the execution environment before handing control to the C <code>main()</code> function.</p> <p>For each new application, the <code>li sp, &lt;address&gt;</code> instruction needs to be modified to set the stack pointer (<code>sp</code>) to the top of DMEM. The stack grows downwards from high memory to low memory. Thus you should set the stack pointer to the very end of your available DMEM.</p> \\[ \\text{Initial SP} = \\text{DMEM_BASE} + \\text{DMEM_SIZE} \\] <p>For example, if your DMEM size is 7KB (the <code>sw/coremark</code> example), and the Hydra-V processor's DMEM base address is <code>0x10010000</code>, then the initial stack pointer should be set to:</p> <pre><code>li sp, 0x10011C00  # 0x10010000 + 7 * 1024\n</code></pre> <p>Success</p> <p>Now you are ready to write, compile, and run your software on the Hydra-V processor! Feel free to move on to explore the existing software applications in the <code>sw/</code> directory.</p>"},{"location":"sw/contributing/","title":"Documentation Workflow","text":"<p>The Hydra-V documentation uses mike to manage multiple versions (e.g., <code>1.0</code>, <code>dev</code>). This process is automated via GitHub Actions.</p>"},{"location":"sw/contributing/#1-daily-development-dev","title":"1. Daily Development (<code>dev</code>)","text":"<p>Any commit pushed to the <code>main</code> branch automatically triggers a deployment to the dev version.</p> <ul> <li>URL: <code>.../Hydra-V/dev/</code></li> <li>Behavior: This version is mutable. New pushes overwrite the previous <code>dev</code> content.</li> </ul>"},{"location":"sw/contributing/#2-publishing-a-release-vxx","title":"2. Publishing a Release (<code>vX.X</code>)","text":"<p>To \"freeze\" the documentation for a specific processor version (e.g., when Version 1.0 RTL is complete), use Git Tags. The CI pipeline detects tags starting with <code>v</code> and creates a permanent documentation snapshot.</p> <p>Steps to release:</p> <ol> <li>Commit your final changes.</li> <li>Tag the commit with the version number (e.g., <code>v1.0</code>).</li> <li>Push the tag to GitHub.</li> </ol> <pre><code># Example: Releasing Version 1.0\ngit commit -am \"Finalize RTL and Docs for v1.0\"\ngit tag v1.0\ngit push origin v1.0\n</code></pre> <p>Results:</p> <ul> <li>A new folder <code>/1.0/</code> is created in the documentation.</li> <li>The <code>latest</code> alias is updated to point to <code>1.0</code>.</li> <li>The default landing page is switched to <code>1.0</code>.</li> </ul>"},{"location":"sw/contributing/#3-pdf-offline-access","title":"3. PDF / Offline Access","text":"<p>The documentation supports exporting the entire site as a single consolidated PDF using the <code>mkdocs-print-site-plugin</code>.</p> <p>How to access: There is currently no direct icon in the navigation bar. To access the printable version, you must manually navigate to the print page:</p> <ol> <li> <p>Navigate to the Print URL:     Append <code>/print_page/</code> (or <code>print_page.html</code>) to the end of the current documentation URL.</p> <ul> <li>Example: <code>.../Hydra-V/dev/print_page/</code></li> </ul> </li> <li> <p>Save as PDF:     Once the consolidated page loads (containing all documentation chapters), use your browser's print function:</p> <ul> <li>Press <code>Ctrl + P</code> (Windows/Linux) or <code>Cmd + P</code> (macOS).</li> <li>Select \"Save as PDF\" as the destination.</li> </ul> </li> </ol>"},{"location":"uarch/","title":"Microarchitecture of Hydra-V Processor","text":"<p>The microarchitecture of Hydra-V is shown in the figure below:</p> <p></p>"},{"location":"uarch/mul-div/","title":"Multiply &amp; Divide Unit","text":"<p>In this version of the Hydra-V processor, the multiply and divide unit is incorporated into one file called <code>MCycle.v</code>. The whole idea of the <code>MCycle</code> module is that, while it is doing the computation, the <code>Busy</code> signal (output) will be triggered high and this signal will be used to stall the other relevant pipeline registers so that no new instructions are fetched until the multiplication/division is complete.</p> <p>This module is implemented using the mealy state machine.</p>"},{"location":"uarch/mul-div/#state-machine-control","title":"State Machine Control","text":""},{"location":"uarch/mul-div/#implementation-details","title":"Implementation Details","text":"<p>I have tried two implementations for the <code>MCycle</code> module:</p> <ul> <li> <p> Native Design</p> <p>Implement the multiply and divide unit by \"hand-typped\" Verilog code.</p> <p> View Documentation</p> </li> <li> <p> Using IP Cores</p> <p>Use Xilinx IP cores to implement the multiply and divide unit.</p> <p> View Documentation</p> </li> </ul>"},{"location":"uarch/mul-div/native-design/","title":"Native Design of Multiply &amp; Divide Unit","text":"<p>This is a follow-up from CG3207 Assignment 3. More specifically, it is my try to finish the first bullet point in the Task 3 of this assignment.</p>"},{"location":"uarch/mul-div/native-design/#multiply-unit","title":"Multiply Unit","text":"<p>For the multiply unit, the idea is to \"unroll\" the loop. For the 32-bit multiplication, instead of using 32 cycles to compute the result by shifting 1 bit a time, I generate the partial products for every 8 bits of the multiplier in parallel. So, the temporal product here will be \\(32+8=40\\) bits wide.</p> <pre><code>module Multiplier32x8 (\n    input  [31:0] A,       // The 32-bit full operand\n    input  [ 7:0] B,       // The 8-bit slice\n    output [39:0] Product  // Result (32 + 8 = 40 bits max)\n);\n\n    // // Generate Partial Products (Shift A based on bit position of B)\n    wire [39:0] pp0 = B[0] ? {8'b0, A} : 40'b0;\n    wire [39:0] pp1 = B[1] ? {7'b0, A, 1'b0} : 40'b0;\n    wire [39:0] pp2 = B[2] ? {6'b0, A, 2'b0} : 40'b0;\n    wire [39:0] pp3 = B[3] ? {5'b0, A, 3'b0} : 40'b0;\n    wire [39:0] pp4 = B[4] ? {4'b0, A, 4'b0} : 40'b0;\n    wire [39:0] pp5 = B[5] ? {3'b0, A, 5'b0} : 40'b0;\n    wire [39:0] pp6 = B[6] ? {2'b0, A, 6'b0} : 40'b0;\n    wire [39:0] pp7 = B[7] ? {1'b0, A, 7'b0} : 40'b0;\n\n    // Sum them up (Tree adder is faster, but this simple chain works also)\n    assign Product = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n</code></pre> <p>In this module, the input <code>A</code> is the full 32-bit multiplicand, while <code>B</code> is an 8-bit slice of the multiplier. The output <code>Product</code> is the 40-bit partial product. For the sliced version of the multiplier, it can be implemented as follows in the state machine control:</p> <pre><code>case (count[1:0])\n    2'b00: current_byte_op2 = abs_op2[7:0];\n    2'b01: current_byte_op2 = abs_op2[15:8];\n    2'b10: current_byte_op2 = abs_op2[23:16];\n    2'b11: current_byte_op2 = abs_op2[31:24];\nendcase\n</code></pre> <p>The final product is then obtained by summing up the 4 partial products with appropriate shifts, which can be implemented as follows:</p> <pre><code>case (count)\n    1: mult_acc = mult_acc + partial_product_out;\n    2: mult_acc = mult_acc + (partial_product_out &lt;&lt; 8);\n    3: mult_acc = mult_acc + (partial_product_out &lt;&lt; 16);\n    4: mult_acc = mult_acc + (partial_product_out &lt;&lt; 24);\nendcase\n</code></pre> <p>And lastly, this module is instantiated in the <code>MCycle</code> module as follows:</p> <pre><code>Multiplier32x8 mul_unit (\n    .A      (abs_op1),\n    .B      (current_byte_op2),\n    .Product(partial_product_out)\n);\n</code></pre> Tip <p>This technique can indeed be implementated using <code>for</code> loop in Verilog as follows:</p> <pre><code>module Multiplier32x8 (\n    input  [31:0] A,       // The 32-bit full operand\n    input  [ 7:0] B,       // The 8-bit slice\n    output [39:0] Product  // Result (32 + 8 = 40 bits max)\n);\n\n    // // Generate Partial Products (Shift A based on bit position of B)\n    wire [39:0] pp0 = B[0] ? {8'b0, A} : 40'b0;\n    wire [39:0] pp1 = B[1] ? {7'b0, A, 1'b0} : 40'b0;\n    wire [39:0] pp2 = B[2] ? {6'b0, A, 2'b0} : 40'b0;\n    wire [39:0] pp3 = B[3] ? {5'b0, A, 3'b0} : 40'b0;\n    wire [39:0] pp4 = B[4] ? {4'b0, A, 4'b0} : 40'b0;\n    wire [39:0] pp5 = B[5] ? {3'b0, A, 5'b0} : 40'b0;\n    wire [39:0] pp6 = B[6] ? {2'b0, A, 6'b0} : 40'b0;\n    wire [39:0] pp7 = B[7] ? {1'b0, A, 7'b0} : 40'b0;\n\n    // Sum them up (Tree adder is faster, but this simple chain works also)\n    assign Product = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n</code></pre> <p>This is totally valid. However, the smart synthesizer will generate the same hardware for both implementations.</p> <p>Warning</p> <p>The 8 bits design will still use more hardware than I thought, which will give around 13ns propagation delay. This will limit the Hydra-V clock frequency to 50MHz max if the clock wizard is not used!</p>"},{"location":"uarch/mul-div/native-design/#divide-unit","title":"Divide Unit","text":"<p>Similarly, I did the unrolling for the divider unit as well. So, instead of getting at most 1 bit of quotient and remainder per cycle. Now, I can get at most 8 bits of quotient and remainder per cycle. This divider unit is implemented using the <code>for</code> loop in Verilog as follows:</p> <pre><code>module DivSlice8 #(\n    parameter width = 32\n) (\n    input      [2*width-1:0] rem_in,   // Current Remainder\n    input      [2*width-1:0] div_in,   // Current Divisor\n    input      [  width-1:0] quot_in,  // Current Quotient (LSW of buffer)\n    output reg [2*width-1:0] rem_out,  // Next Remainder\n    output reg [2*width-1:0] div_out,  // Next Divisor\n    output reg [  width-1:0] quot_out  // Next Quotient\n);\n\n    // Temporary variable for subtraction\n    integer             i;\n    reg     [2*width:0] diff_ext;\n\n    always @(*) begin\n        // Initialize temporary variables with inputs\n        rem_out = rem_in;\n        div_out = div_in;\n        quot_out = quot_in;\n\n        // Perform 8 iterations of division logic (Combinational Loop)\n        for (i = 0; i &lt; 8; i = i + 1) begin\n            // 1. Subtract: Remainder - Divisor\n            diff_ext = {1'b0, rem_out} + {1'b0, ~div_out} + 1'b1;\n\n            // 2. Check Sign\n            if (diff_ext[2*width] == 1'b1) begin\n                // Result Positive: Update Remainder, Shift 1 into Quotient\n                rem_out = diff_ext[2*width-1:0];\n                quot_out = {quot_out[width-2:0], 1'b1};\n            end else begin\n                // Result Negative: Keep Remainder, Shift 0 into Quotient\n                quot_out = {quot_out[width-2:0], 1'b0};\n            end\n\n            // 3. Shift Divisor Right for the next step\n            div_out = {1'b0, div_out[2*width-1:1]};\n        end\n    end\nendmodule\n</code></pre> <p>To use the result from the divider unit, the state machine control can just be modified by updating the current remainder and quotient to be the result from the divider unit after each cycle:</p> <pre><code>if (count &gt; 0) begin\n    rem = next_rem;\n    div = next_div;\n    div_result_buf[width-1:0] = next_quot;\n    div_result_buf[2*width-1:width] = rem[width-1:0];\nend\n</code></pre> <p>And finally, this divider unit is implemented as follows in the <code>MCycle</code> module:</p> <pre><code>DivSlice8 div_unit (\n    .rem_in  (rem),\n    .div_in  (div),\n    .quot_in (div_result_buf[width-1:0]),\n    .rem_out (next_rem),\n    .div_out (next_div),\n    .quot_out(next_quot)\n);\n</code></pre> <p>Warning</p> <p>Using the unrolling techniue in the divider unit here will use a lot of hardware! iirc, the propagation delay is around 66ns for this design! Given that high propagation delay, it is impossible to use this design on Hydra-V. So, I moved on to the next section, which is to use Xilinix IP core for the multiply and divide unit.</p>"},{"location":"uarch/mul-div/vendor-ip/","title":"AMD IP Design","text":"<p>As mentioned in the previous documentation, if I only use the unrolling technique, it is impossible to reach higher frequency while keeping the cycles for multiplication and division low. Therefore, I decided to use the AMD IP cores (Multiplier and Divider) to implement the multiply and divide unit.</p>"},{"location":"uarch/mul-div/vendor-ip/#generate-the-ip-core","title":"Generate the IP Core","text":""},{"location":"uarch/mul-div/vendor-ip/#multiplier-ip","title":"Multiplier IP","text":"<p>The multiplier IP core comes from AMD and can be used in Vivado directly.</p> <p>To use the IP in Vivado, click the \"IP Catalog\" on the left flow navigator. Then, search for \"multiplier\". Click the \"Multiplier\" (not \"Complex Multiplier\"). And the configure the IP to use the following settings:</p> <ol> <li>In the \"Basic\" tab:<ul> <li>Set Multiplier Type to \"Parallel Multiplier\"</li> <li>Set <code>A</code> and <code>B</code> to be \"unsigned\" and \"32-bit\" wide</li> <li>Set Multiplier Construction to \"Use Mults\"</li> <li>Set the Optimization Options to \"Speed Optimized\"</li> </ul> </li> <li>In the \"Output and Control\" tab<ul> <li>Make sure the <code>P</code> (output) is 64-bit wide.</li> <li>Set the Pipeline Stages to 4.</li> </ul> </li> </ol> <p>Tip</p> <p>With the above settings, the multiplier IP core will take 5 cycles to complete and the propagation is safer for the processor to reach 100MHz and higher.</p>"},{"location":"uarch/mul-div/vendor-ip/#divider-ip","title":"Divider IP","text":"<p>Simiarly, the divider IP core also comes from AMD and can be used in Vivado directly.</p> <p>Follow the similar steps as the multiplier IP core, but configure the divider using the following settings:</p> <ol> <li>In the \"Channel Settings\" tab:<ul> <li>Set Algorithm type of \"Radix 2\" and Operand sign to \"unsigned\".</li> <li>Change dividend and divisor width to \"32\".</li> <li>Set the Remainder Type to be \"Remainder\" and fractional width to be \"32\".</li> </ul> </li> <li>In the \"Options\" tab:<ul> <li>Set Clocks per Division to be \"1\".</li> <li>Set the flow control under AXI4-Stream settings to \"Blocking\".</li> <li>Set the optimize goal under AXI4-Stream settings to \"Performance\".</li> </ul> </li> </ol> <p>Tip</p> <p>With the above settings, the divider IP core will take 32 cycles to complete and the propagation is safer for the processor to reach 100MHz and higher.</p>"},{"location":"uarch/mul-div/vendor-ip/#use-ip-core","title":"Use IP Core","text":"<p>To use the two IP cores that we have generated above, we just need to know the inputs and outputs of each IP core and then instantiate them in our <code>MCycle.v</code> to replace the multiple unit and the divide unit that we have implemented manually in the previous section.</p> <pre><code>// Multiplier IP: 32x32 Unsigned -&gt; 64-bit Product\nmult_gen_0 my_multiplier (\n    .CLK(CLK),\n    .A  (abs_op1),\n    .B  (abs_op2),\n    .P  (mul_dout)\n);\n\n// Divider IP: 32/32 Unsigned -&gt; 32 Quot, 32 Rem\ndiv_gen_0 my_divider (\n    .aclk                  (CLK),\n    .s_axis_divisor_tvalid (div_in_valid),\n    .s_axis_divisor_tdata  (abs_op2),\n    .s_axis_dividend_tvalid(div_in_valid),\n    .s_axis_dividend_tdata (abs_op1),\n    .m_axis_dout_tvalid    (div_out_valid),\n    .m_axis_dout_tdata     (div_dout)\n);\n</code></pre>"}]}