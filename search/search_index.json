{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Mach-V Documentation","text":"<p>Welcome to the Mach-V Documentation!</p>"},{"location":"sim/","title":"Simulation","text":"<p>This section outlines the verification strategy for the Mach-V processor.</p>"},{"location":"sim/#simulation-directory-structure","title":"Simulation Directory Structure","text":"<p>The <code>sim/</code> directory contains all testbench and verification artifacts:</p> <ul> <li><code>sim/tb/</code>: Verilog testbenches mapped to specific software applications.</li> <li><code>sim/mem/</code>: Pre-compiled memory files (in hexadecimal format) used to initialize IROM and DMEM for simulation.</li> </ul>"},{"location":"sim/#toolchain-setup","title":"Toolchain Setup","text":"<p>The primary tool used for simulation is Vivado 2025.2. For installation instructions, refer to the NUS CG3207 Lab Guide or consult the official Xilinx documentation.</p>"},{"location":"sim/#simulation-guide","title":"Simulation Guide","text":"<p>Simulations for Mach-V are performed by targeting the Wrapper.v module as the Device Under Test (DUT). Acting effectively as a virtual motherboard, this module connects the processor core to peripherals like UART and memory.</p>"},{"location":"sim/#debugging-the-pipelined-processor","title":"Debugging the Pipelined Processor","text":"<p>Personally speaking, debugging a pipelined microarchitecture can be tedious due to instructions overlapping across different stages. To simplify this process, I recommend propagating the current PC value through every stage of the pipeline.</p> <p>By latching <code>PCF</code> into successive pipeline registers (e.g., <code>PCD</code>, <code>PCE</code>, <code>PCM</code>, <code>PCW</code>), you can easily identify exactly which instruction is occupying a specific stage at any given cycle.</p> <p>For example, the waveform below shows the Decode (Dec) stage while executing the Coremark application:</p> <p></p> <p>Decode Stage with PC Propagation</p> <p>In the waveform above, the <code>PCD</code> signal indicates the instruction currently residing in the Dec stage. This makes it significantly easier to verify if the control signals match the expected behavior. For reference, here is the corresponding snippet from <code>prog.dump</code>:</p> <pre><code>400000:   0080006f           j 400008 &lt;_init_reg&gt;\n400004:   0000006f           j 400004 &lt;_end&gt;\n400008:   00000093           li ra,0\n40000c:   00000113           li sp,0\n400010:   00000193           li gp,0\n400014:   00000213           li tp,0\n</code></pre> <p>Warning</p> <p>While this method has been effective for Phase 2 of Mach-V, there may be more efficient debugging techniques. I will continue to explore other methods and update this section as the design evolves.</p>"},{"location":"sim/#handling-fly-away-situations-undefined-states","title":"Handling \"Fly-Away\" Situations (Undefined States)","text":"<p>Occasionally, you may encounter a situation where signals (such as <code>PCF</code>) suddenly transition to <code>XXX</code> (undefined). This usually indicates that the processor has entered an invalid state. These issues can be difficult to trace, but below are some common causes I have encountered.</p> <p>Rule of Thumb</p> <p>Locate the last valid instruction in the waveform before the signals go undefined. Use the PC value of that instruction to find the corresponding RISC-V instruction in your <code>prog.dump</code> file (generated after running <code>make</code>).</p>"},{"location":"sim/#lw-loading-from-an-invalid-address","title":"<code>lw</code> Loading from an Invalid Address","text":"<p>This issue typically occurs when a load instruction attempts to access an address that is not mapped to the DMEM. If the data is missing from the memory initialization, the simulation returns undefined values.</p> <p>To resolve this, check if the source address of the load instruction falls within a section that has been put into the DMEM. This kind of information is specified in the linker script (<code>ld.script</code>).</p> <p>Tip</p> <p>A common pitfall is the <code>.rodata</code> (read-only data) section. Ensure that <code>.rodata</code> is explicitly included in the DMEM mapping in your linker script.</p>"},{"location":"sim/benchmark_tb/","title":"Benchmark Testbench","text":"<p>This testbench is designed for non-interactive applications, such as the CoreMark benchmark. Its primary goal is to run the processor at full speed and capture the output without requiring manual user input.</p>"},{"location":"sim/benchmark_tb/#key-features","title":"Key features","text":""},{"location":"sim/benchmark_tb/#zero-stall-uart-configuration","title":"Zero-Stall UART Configuration","text":"<p>Since the benchmark relies on printf for reporting results but has no human operator, the UART input is disabled, and the output is forced to be \"always ready.\"</p> <ul> <li>RX (Input): <code>UART_RX_valid</code> is tied to <code>0</code>, ensuring the CPU never receives spurious input.</li> <li>TX (Output): <code>UART_TX_ready</code> is hardcoded to <code>1</code>, preventing the CPU from stalling while waiting for the terminal to accept a character.</li> </ul>"},{"location":"sim/benchmark_tb/#output-monitoring","title":"Output Monitoring","text":"<p>Instead of opening a graphical terminal, the testbench monitors the <code>UART_TX</code> line directly. Whenever the CPU asserts <code>UART_TX_valid</code>, the testbench grabs the character and prints it to the Vivado Tcl console using <code>$display</code>.</p> <pre><code>always @(posedge CLK) begin\n    if (UART_TX_valid) begin\n        // Prints the ASCII character sent by the CPU\n        $display(\"UART_TX: %h\", UART_TX); \n    end\nend\n</code></pre>"},{"location":"sim/benchmark_tb/#simulation-timeout","title":"Simulation Timeout","text":"<p>To prevent the simulation from running indefinitely (in case of software crashes or infinite loops), a hard limit is set. The simulation automatically stops after 50ms (5,000,000,000 ns), which is sufficient for one iteration of the benchmark.</p>"},{"location":"sim/uart_tb/","title":"UART Application Testbench","text":"<p>This testbench verifies the interactive capabilities of the processor, specifically focusing on the UART Calculator application. Unlike the benchmark simulation, this testbench actively injects data and adheres to a strict handshaking protocol.</p>"},{"location":"sim/uart_tb/#the-send_uart-task","title":"The <code>send_uart</code> Task","text":"<p>The core of this verification is the <code>send_uart</code> task, which automates the entry of complex commands. It constructs a 9-byte packet consisting of:</p> <ol> <li>Command Byte: The ASCII character for the operation. (e.g., <code>d</code> for division. For the full list of commands, refer to the UART Calculator documentation.)</li> <li>Operand 1 (4 bytes): The first 32-bit number.</li> <li>Operand 2 (4 bytes): The second 32-bit number.</li> </ol>"},{"location":"sim/uart_tb/#handshaking-protocol","title":"Handshaking Protocol","text":"<p>The task simulates a real UART controller by waiting for the CPU to acknowledge receipt of each byte before sending the next.</p> <pre><code>// Wait until CPU acknowledges (reads from UART_RX)\nwait (UART_RX_ack == 1); \nUART_RX_valid = 0;\n// Wait until CPU clears ack before sending next byte\nwait (UART_RX_ack == 0);\n</code></pre>"},{"location":"sim/uart_tb/#test-coverage","title":"Test Coverage","text":"<p>You are encouraged to extend tb_uart.v with additional test cases to verify specific scenarios. When adding new tests, please refer to the UART Calculator Command Reference to ensure the correct the command code is used.</p>"},{"location":"sw/","title":"Software Development Guide","text":"<p>This guide explains how to write, compile, and run different software on the Mach-V processor.</p>"},{"location":"sw/#software-directory-structure","title":"Software Directory Structure","text":"<p>The <code>sw/</code> directory is organized by application. For example:</p> <ul> <li><code>sw/coremark/</code> contains the CoreMark benchmark source code and build scripts.</li> </ul>"},{"location":"sw/#system-memory-map","title":"System Memory Map","text":"<p>Followed by the convention set in NUS CG3207, the Mach-V processor uses a memory-mapped I/O architecture. The address space is divided into Instruction Memory, Data Memory, and Peripheral (MMIO) regions.</p> <p>Configuration Source</p> <p>The memory capacities defined below are determined by parameters in <code>Wrapper.v</code>. For example, <pre><code>localparam IROM_DEPTH_BITS = 15;     // for 2^15 words = 32KB\nlocalparam DMEM_DEPTH_BITS = 14;     // for 2^14 words = 16KB\nlocalparam MMIO_DEPTH_BITS = 8;      // for 2^8 words = 1KB\n</code></pre></p> <p>If you modify these parameters in <code>Wrapper.v</code>, you must update your linker script and stack initialization accordingly.</p>"},{"location":"sw/#main-memory","title":"Main Memory","text":"Address Range Name Permissions Description <code>0x00400000 \u2013 0x00407FFF</code> IROM (Instruction Memory) RO (Read-Only) Capacity: 8,192 words (32 KB). Based on <code>IROM_DEPTH_BITS = 15</code>. <code>0x10010000 \u2013 0x10013FFF</code> DMEM (Data Memory) RW (Read-Write) Capacity: 4,096 words (16 KB). Used for storing constants and variables. Based on <code>DMEM_DEPTH_BITS = 14</code>. <p>Addressing Constraints</p> <p>Accesses must be aligned to 4-byte boundaries.</p>"},{"location":"sw/#memory-mapped-peripherals-mmio","title":"Memory-Mapped Peripherals (MMIO)","text":"<p>All peripherals are mapped to the upper memory range starting at <code>0xFFFFxxxx</code>.</p>"},{"location":"sw/#communication-uart","title":"Communication (UART)","text":"Address Register Name Perms Description <code>0xFFFF0000</code> UART_RX_VALID RO Receive Status. Data is valid to read from <code>UART_RX</code> only when the LSB (Least Significant Bit) of this register is set to 1. <code>0xFFFF0004</code> UART_RX RO Receive Data. Reads input from the keyboard. Only the LSByte (lowest 8 bits) contains valid data. <code>0xFFFF0008</code> UART_TX_READY RO Transmit Status. Data is safe to write to <code>UART_TX</code> only when the LSB of this register is set to 1. <code>0xFFFF000C</code> UART_TX WO Transmit Data. Sends output to the display/console. Only the LSByte is writeable."},{"location":"sw/#on-board-io-gpio","title":"On-Board I/O (GPIO)","text":"Address Register Name Perms Description <code>0xFFFF0060</code> LED WO LED control register <code>0xFFFF0064</code> DIP RO DIP switch input register <code>0xFFFF0068</code> PB RO Push button input register <code>0xFFFF0080</code> SEVENSEG WO 7-segment display output register <p>Register Details</p> <code>LED -- 0xFFFF0060 (WO)</code> <p>The lower 8 bits are user-writeable. The upper bits are hardwired as follows:</p> <ul> <li>[7:0] user writeable,</li> <li>[8] divided clock,</li> <li>[15:9] program counter <code>[8:2]</code>.</li> </ul> <code>DIP -- 0xFFFF0064 (RO)</code> <p>Reads the state of the 16 on-board switches, covering switch range SW15\u2013SW0.</p> <code>PB -- 0xFFFF0068 (RO)</code> <p>Only the lowest 3 bits are valid.</p> <ul> <li>[2] BTNR (Right),</li> <li>[1] BTNC (Center),</li> <li>[0] BTNL (Left).</li> </ul> <p>The remaining buttons are hardwired: BTND resets the system, while BTNU pauses execution.</p> <code>SEVENSEG -- 0xFFFF0080 (WO)</code> <p>Writes an 8-digit hexadecimal number to the 7-segment display.</p>"},{"location":"sw/#sensor-display-modules","title":"Sensor &amp; Display Modules","text":"Address Register Name Perms Description <code>0xFFFF0020</code> OLED_COL WO Sets the OLED pixel column index (0 \u2013 95). <code>0xFFFF0024</code> OLED_ROW WO Sets the OLED pixel row index (0 \u2013 63). <code>0xFFFF0028</code> OLED_DATA WO Writes data to the pixel. Format depends on <code>OLED_CTRL</code>. <code>0xFFFF002C</code> OLED_CTRL WO Controls OLED data format and operation modes. <code>0xFFFF0040</code> ACCEL_DATA RO Reads accelerometer data (refer to peripherals documentation for format). <code>0xFFFF0044</code> ACCEL_DREADY RO Data Ready. LSB is set when a new reading is available."},{"location":"sw/#system-counters","title":"System Counters","text":"Address Register Name Perms Description <code>0xFFFF00A0</code> CYCLECOUNT RO Returns the number of clock cycles elapsed since system reset."},{"location":"sw/#toolchain-setup","title":"Toolchain Setup","text":"<p>I used the RISC-V GNU Toolchain to compile C code into machine code (hex files) and then load them into the Mach-V processor's IROM (<code>AA_IROM.mem</code>) and DMEM (<code>AA_DMEM.mem</code>).</p>"},{"location":"sw/#install-toolchain","title":"Install Toolchain","text":"<p>The toolchain that I used is pre-built and can be found on GitHub. I chose the <code>rv32i-131023</code> version. The installation guide is also available on the repository.</p>"},{"location":"sw/#build-configuration","title":"Build Configuration","text":"<p>To compile C code into hex files for IROM and DMEM, I used three files: <code>Makefile</code>, <code>ld.script</code> and <code>crt.s</code>. For every C program that is newly written, these three files need to be added and modified accordingly.</p>"},{"location":"sw/#makefile","title":"<code>Makefile</code>","text":"<p><code>Makefile</code> defines the rules for the <code>make</code> command to work. Make sure the <code>GCC_DIR</code> is correct and feel free to change the <code>CFLAGS</code> as you wish (like changing the Optimization flag from <code>-O2</code> to <code>-O3</code> etc).</p> <p>Info</p> <p>You can get a template from any one of the application, but I recommend the <code>sw/calculator/Makefile</code>.</p>"},{"location":"sw/#ldscript","title":"<code>ld.script</code>","text":"<p><code>ld.script</code> first specifies the size left for IROM and DMEM. In the Mach-V processor,</p> <ul> <li><code>ROM</code> stands for IROM, its <code>ORIGIN</code> is <code>0x00400000</code>, its <code>LENGTH</code> depends on the size of the <code>code.hex</code> generated.</li> <li><code>RAM</code> stands for DMEM, its <code>ORIGIN</code> is <code>0x10010000</code>, its <code>LENGTH</code> depends on the size of the <code>data.hex</code> generated.</li> </ul> <p>Secondly, it specifies which section in the compiled program goes to which memory region. This determines which part of the program is stored in IROM and which part is stored in DMEM. For example,</p> <ul> <li>the <code>.rodata</code> and <code>.data</code> sections are dumped into DMEM</li> <li>the <code>.text</code> section is dumped into IROM.</li> </ul>"},{"location":"sw/#crts","title":"<code>crt.s</code>","text":"<p>The <code>crt.s</code> file is the entry point of the software. It sets up the execution environment before handing control to the C <code>main()</code> function.</p> <p>For each new application, the <code>li sp, &lt;address&gt;</code> instruction needs to be modified to set the stack pointer (<code>sp</code>) to the top of DMEM. The stack grows downwards from high memory to low memory. Thus you should set the stack pointer to the very end of your available DMEM.</p> \\[ \\text{Initial SP} = \\text{DMEM_BASE} + \\text{DMEM_SIZE} \\] <p>For example, if your DMEM size is 7KB (the <code>sw/coremark</code> example), and the Mach-V processor's DMEM base address is <code>0x10010000</code>, then the initial stack pointer should be set to:</p> <pre><code>li sp, 0x10011C00  # 0x10010000 + 7 * 1024\n</code></pre>"},{"location":"sw/#compile-and-load","title":"Compile and Load","text":"<p>After setting up the three files above, you can simply run the <code>make</code> command in the terminal while being in the application's directory. If everything is set up correctly, two hex files named <code>code.hex</code> and <code>data.hex</code> will be generated. Copy and paste the contents of <code>code.hex</code> into <code>AA_IROM.mem</code> and <code>data.hex</code> into <code>AA_DMEM.mem</code> in the Vivado project to load the program into the Mach-V processor.</p> <p>To clean up the generated files, you can run <code>make clean</code>.</p> <p>Success</p> <p>Now you are ready to write, compile, and run your software on the Mach-V processor! Feel free to move on to explore the existing software applications in the <code>sw/</code> directory.</p>"},{"location":"sw/benchmark/","title":"CoreMark Benchmark","text":"<p>The CoreMark benchmark is used to evaluate the performance of the Mach-V processor. It measures the CPU's ability to handle list processing, matrix manipulation, and state machine execution.</p>"},{"location":"sw/benchmark/#source-code-organization","title":"Source Code Organization","text":"<p>The CoreMark source code and build scripts are located in the <code>sw/coremark/</code> directory.</p>"},{"location":"sw/benchmark/#porting-implementation","title":"Porting Implementation","text":"<p>The CoreMark port for Mach-V is based on the barebones implementation. To adapt it for the Mach-V memory map, modifications are required in <code>sw/coremark/barebones/core_portme.c</code> and <code>sw/coremark/barebones/ee_printf.c</code>.</p>"},{"location":"sw/benchmark/#system-timer","title":"System Timer","text":"<p>CoreMark requires a method to measure time to calculate the performance score. In <code>core_portme.c</code>, the <code>barebones_clock()</code> function is modified to read the Mach-V <code>CYCLECOUNT</code> system counter.</p> <p>Modification: Update <code>hardwareCounterAddr</code> to point to the Mach-V system counter address (<code>0xFFFF00A0</code>).</p> <pre><code>CORETIMETYPE barebones_clock() {\n    // Pointer to the Mach-V System Counter (CYCLECOUNT)\n    volatile unsigned int* hardwareCounterAddr = (unsigned int*)0xffff00a0;\n\n    unsigned int hardwareCounter;\n\n    // Read hardwareCounter (Execution Cycle)\n    hardwareCounter = *hardwareCounterAddr;\n\n    return (CORETIMETYPE)hardwareCounter;\n}\n</code></pre>"},{"location":"sw/benchmark/#uart-output","title":"UART Output","text":"<p>To output the benchmark results to the console, the UART transmission function must be mapped to the correct MMIO addresses.</p> <p>Modification: In <code>ee_printf.c</code>, update the pointers in <code>uart_send_char()</code> to match the Mach-V UART peripheral addresses. The relevant addresses are introduced in System Memory Map.</p> <pre><code>void uart_send_char(char c) {\n    volatile unsigned int *UART_TX_READY_ADDR = (unsigned int*)0xFFFF0008;\n    volatile unsigned char *UART_TX_ADDR = (unsigned char*)0xFFFF000C;\n\n    // Wait until UART is ready (LSB == 1 indicates ready)\n    while ((*UART_TX_READY_ADDR &amp; 0x1) == 0);\n\n    // Write character to the transmission buffer\n    *UART_TX_ADDR = c;\n\n    // Optional: Wait for transmission completion\n    while ((*UART_TX_READY_ADDR &amp; 0x1) == 0);\n}\n</code></pre>"},{"location":"sw/benchmark/#build-configuration","title":"Build Configuration","text":""},{"location":"sw/benchmark/#setting-clock-frequency","title":"Setting Clock Frequency","text":"<p>To ensure the CoreMark score (Iterations/Sec) is calculated correctly, the build script must know the target processor frequency.</p> <p>Modify the <code>Makefile</code> under <code>sw/coremark</code> to set the <code>CLOCKS_PER_SEC</code> flag. This value must match the frequency of the Mach-V processor. For example, for a design running at 50 MHz:</p> <pre><code>CLOCKS_PER_SEC = 50000000\n</code></pre> <p>Warning</p> <p>If <code>CLOCKS_PER_SEC</code> does not match the actual hardware clock frequency, the reported CoreMark/MHz score will be mathematically incorrect.</p> <p>Ready to Run</p> <p>With the porting layer configured and the frequency set, the CoreMark benchmark is ready to run on Mach-V!</p>"},{"location":"sw/resources/","title":"Resoures &amp; Utilities","text":"<p>This section contains utility guides and extra information regarding the Mach-V software stack.</p>"},{"location":"sw/resources/#offline-access","title":"Offline Access","text":"<p>This documentation supports exporting the entire site as a single, consolidated PDF for offline reading. This is powered by the <code>mkdocs-print-site-plugin</code>.</p>"},{"location":"sw/resources/#export-to-pdf","title":"Export to PDF","text":"<p>Currently, there is no direct download button in the navigation bar. You can generate the PDF manually by following these steps:</p> <ol> <li>Access the Print View: Navigate to the consolidated print view by appending <code>print_page/</code> to the base URL of the documentation. For example, go to <code>https://mendax1234.github.io/Mach-V/print_page/</code>.</li> <li>Print to PDF: Once the page loads (it may take a moment to render all chapters):<ol> <li>Open your browser's print dialog (<code>Ctrl + P</code> on Windows/Linux or <code>Cmd + P</code> on macOS).</li> <li>Set the Destination to \"Save as PDF\".</li> <li>Click Save.</li> </ol> </li> </ol> <p>Formatting</p> <p>For the best layout, ensure Background graphics is checked in your browser's print settings to preserve syntax highlighting and admonition colors.</p>"},{"location":"sw/resources/#useful-links","title":"Useful Links","text":"<p>The success of Mach-V cannot be achieved without the help of many open-source projects and resources. Here are some useful links that you may find helpful when working with Mach-V:</p> <ul> <li> <p> CoreMark Benchmark</p> <p>Official CoreMark benchmark by EEMBC, widely used to evaluate embedded processor performance.</p> <p> Visit EEMBC</p> </li> <li> <p> CoreMark on Bare-Metal Systems</p> <p>CoreMark running on bare-bone RISC-V systems, including build scripts and platform-specific adaptations.</p> <p> View on GitHub</p> </li> <li> <p> Pre-built RISC-V GNU Toolchain</p> <p>Pre-compiled RISC-V GCC toolchain for rapid development without building from source.</p> <p> Download Toolchain</p> </li> </ul>"},{"location":"sw/uart_calculator/","title":"UART Calculator","text":"<p>This is a simple calculator program that is used to test the basic functionality of the Mach-V processor. It contains all the basic instructiosn from RISC-V I and M extensions, and performs arithmetic operations based on user input via UART.</p>"},{"location":"sw/uart_calculator/#source-code-organization","title":"Source Code Organization","text":"<p>The source code for the UART Calculator is located in the <code>sw/uart_calculator/</code> directory. The main source file is <code>uart_calculator.c</code>, which contains the implementation of the calculator logic and UART communication.</p>"},{"location":"sw/uart_calculator/#porting-implementation","title":"Porting Implementation","text":""},{"location":"sw/uart_calculator/#uart-output","title":"UART Output","text":"<p>As the calculator uses UART to communicate with the Mach-V processor, if the MMIO addresses are changed, the code in <code>uart_calculator.c</code> must be updated accordingly. The MMIO definitions are located at the top of the <code>uart_calculator.c</code> file,</p> <pre><code>#define MMIO_BASE 0xFFFF0000\n#define UART_RX_VALID_OFF 0x00\n#define UART_RX_DATA_OFF 0x04\n#define UART_TX_READY_OFF 0x08\n#define UART_TX_DATA_OFF 0x0C\n#define SEVENSEG_OFF 0x80\n</code></pre> <p>Info</p> <p>If you are using different MMIO addresses for UART or other peripherals, make sure to update these definitions accordingly.</p>"},{"location":"sw/uart_calculator/#dmem-initialization","title":"DMEM Initialization","text":"<p>The application pre-loads data into Data Memory (DMEM) to test Load/Store instructions. This is handled via initialized global arrays in C, which the linker places in the <code>.data</code> section.</p> <pre><code>// Pre-loaded test patterns for Load operations\nuint32_t test_data[4] = {\n    0x12345678,\n    0x9ABCDEF0,\n    0xAABBCCDD,\n    0xEEFF0011};\n</code></pre>"},{"location":"sw/uart_calculator/#build-configuration","title":"Build Configuration","text":"<p>There is nothing much to customize or change in the <code>Makefile</code>, <code>ld.script</code> and <code>crt.s</code> files for this application. This is also why this application can be regarded as a template for other new applications.</p>"},{"location":"sw/uart_calculator/#application-usage","title":"Application Usage","text":"<p>The calculator operates using a strictly defined 9-byte communication protocol over UART.</p>"},{"location":"sw/uart_calculator/#communication-protocol","title":"Communication Protocol","text":"<p>For every operation, the user must send exactly 9 bytes to the processor:</p> <ol> <li>Command 1(1 Byte): An ASCII character selecting the operation (see table below).</li> <li>Operand 1(4 Bytes): The first 32-bit argument, sent Big-Endian (MSB first).</li> <li>Operand 2(4 Bytes): The second 32-bit argument, sent Big-Endian (MSB first).</li> </ol> <p>Output: The result of the operation is written to the 7-segment Display MMIO address.</p>"},{"location":"sw/uart_calculator/#command-reference","title":"Command Reference","text":"Category Command ASCII Operation Description Arithmetic ADD a op1 + op2 32-bit Addition SUB s op1 - op2 32-bit Subtraction Logical AND c op1 &amp; op2 Bitwise AND OR o op1 | op2 Bitwise OR XOR x op1 ^ op2 Bitwise XOR Shift SLL L op1 &lt;&lt; op2 Shift Left Logical SRL R op1 &gt;&gt; op2 Shift Right Logical SRA A op1 &gt;&gt; op2 Shift Right Arithmetic (sign-extended) Comparison SLT l op1 &lt; op2 Set if Less Than (Signed) SLTU u op1 &lt; op2 Set if Less Than (Unsigned) Multiply / Div MUL m op1 * op2 Low 32 bits of product MULH H op1 * op2 High 32 bits (Signed) MULHU h op1 * op2 High 32 bits (Unsigned) DIV d op1 / op2 Signed Division DIVU D op1 / op2 Unsigned Division REM r op1 % op2 Signed Remainder REMU M op1 % op2 Unsigned Remainder Memory Access LOAD 1..4 Mem[op1] Reads from <code>test_data</code>. 1=LB, 2=LBU, 3=LH, 4=LHU STORE 5..6 Mem[op1] = op2 Writes to <code>scratch_mem</code>. 5=SB, 6=SH"},{"location":"sw/changelog/","title":"Changelog","text":""},{"location":"sw/changelog/#mach-v-processor","title":"Mach-V Processor","text":""},{"location":"sw/changelog/#2.0","title":"2.0  Dec 20, 2025","text":"<p>Focus: Timing optimization and hardware acceleration.</p> <ul> <li>Enhanced Clock Frequency: Integrated Clock Wizard to boost operating frequency to 115 MHz (from 100 MHz baseline).</li> <li>Critical Path Optimization: Relocated PC logic from the Execute (EXE) stage to the Memory (MEM) stage to relax timing constraints.</li> <li>Hardware-Accelerated Arithmetic: Replaced native multiplier/divider designs with optimized AMD/Xilinx IP cores for high-performance integer arithmetic.</li> </ul>"},{"location":"sw/changelog/#1.0","title":"1.0  Nov 15, 2025","text":"<p>Focus: Baseline implementation featuring a classic RISC-V scalar architecture.</p> <ul> <li>Classic 5-Stage Pipeline: Implemented standard Fetch, Decode, Execute, Memory, and Writeback stages.</li> <li>Comprehensive Hazard Management: Added dedicated hardware for data forwarding and hazard detection to resolve data/control hazards.</li> <li>Scalar In-Order Execution: Established single-issue sequential execution ensuring deterministic behavior and architectural simplicity.</li> </ul>"},{"location":"sw/changelog/conventions/","title":"Conventions","text":"<p>This section explains the symbols and conventions used throughout the Mach-V documentation.</p>"},{"location":"sw/changelog/conventions/#symbols","title":"Symbols","text":"<p>The documentation uses visual badges to denote specific hardware states, version requirements, or configuration settings. Please familiarize yourself with the following conventions:</p>"},{"location":"sw/changelog/conventions/#version","title":"\u2013 Version","text":"<p>The tag symbol denotes the Mach-V Core Version required for a specific feature or architectural change. Ensure your hardware description (RTL) matches this version tag to guarantee compatibility.</p>"},{"location":"sw/changelog/conventions/#feature","title":"\u2013 Optional Feature","text":"<p>This symbol indicates a hardware module (such as the Branch Predictor or FPU) that is not included in the core by default. These features must be explicitly enabled via Verilog defines (e.g., <code>`define ENABLE_FPU</code>) in your configuration file.</p>"},{"location":"sw/changelog/conventions/#plugin","title":"\u2013 External IP / Plugin","text":"<p>This symbol refers to External IP Cores (like Xilinx Clock Wizards or AMD Multipliers) or software plugins used in the project. These components may require specific vendor licenses or additional synthesis libraries.</p>"},{"location":"sw/changelog/conventions/#experimental","title":"\u2013 Experimental","text":"<p>Features marked with the flask symbol are currently being tested on the FPGA and may be unstable. The timing closure or logic correctness for these features is not yet guaranteed in all corner cases.</p>"},{"location":"sw/changelog/conventions/#default","title":"\u2013 Default Value","text":"<p>Indicates the default reset value of a hardware register or a configuration parameter if not otherwise specified by the software bootloader.</p>"},{"location":"uarch/","title":"Microarchitecture","text":""},{"location":"uarch/#performance-benchmark","title":"Performance Benchmark","text":"<p>Here is the performance scaling of the Mach-V core running the CoreMark benchmark.</p> <p> </p>"},{"location":"uarch/#microarchitecture-overview","title":"Microarchitecture Overview","text":"<p>The microarchitecture of Mach-V has currently evolved through two distinct iterations:</p> Mach-V Version 1Mach-V Version 2 <p></p> <p>Mach-V Microarchitecture - Version 1</p> <p>Mach-V Version 1 serves as the baseline implementation, featuring a classic RISC-V scalar architecture:</p> <ol> <li>Classic 5-Stage Pipeline: Implements the standard Fetch, Decode, Execute, Memory, and Writeback stages for balanced throughput.</li> <li>Comprehensive Hazard Management: Dedicated hardware for data forwarding and hazard detection resolves data and control hazards automatically.</li> <li>Scalar In-Order Execution: Issues, executes, and commits instructions sequentially (single-issue) to ensure deterministic behavior and architectural simplicity.</li> </ol> <p></p> <p>Mach-V Microarchitecture - Version 2</p> <p>Mach-V Version 2 focuses on timing optimization and hardware acceleration, introducing the following enhancements:</p> <ol> <li>Enhanced Clock Frequency: Integrated Clock Wizard boosts the operating frequency to 115 MHz (surpassing the 100 MHz baseline).</li> <li>Critical Path Optimization: PC logic is relocated from the Execute (EXE) stage to the Memory (MEM) stage to relax timing constraints.</li> <li>Hardware-Accelerated Arithmetic: Replaces native design with optimized AMD/Xilinx IP cores for high-performance integer multiplication and division.</li> </ol>"},{"location":"uarch/alu/","title":"Arithmetic &amp; Logic Unit (ALU)","text":"<p>The Mach-V ALU is a streamlined execution unit derived from the reference design used in NUS CG3207. It implements standard RISC-V integer arithmetic and logical operations, utilizing a barrel shifter designed by NUS CG3207 teaching team for efficient single-cycle shift operations.</p>"},{"location":"uarch/alu/#zero-flag-optimization","title":"Zero Flag Optimization","text":"<p>2.0 </p> <p>While the base architecture is inherited, a critical timing optimization was introduced to the Zero (Z) flag generation. In the reference design, the Z flag is typically derived from the final <code>ALUResult</code> (after the result multiplexer). This creates a long logic chain: <code>Adder -&gt; Result Mux -&gt; Zero Check</code>.</p> <p>To reduce the critical path, Mach-V computes the Z flag directly from the 33-bit adder output (<code>Sum</code>) in parallel with the result multiplexer. This decouples the flag generation from the multiplexing logic, significantly reducing propagation delay.</p> <pre><code>// Critical Path Optimization: \n// Calculate Zero flag from the intermediate Sum rather than the final ALUResult\nassign Z = (Sum[31:0] == 32'b0);\n</code></pre> <p>Timing Closure</p> <p>This optimization is mandatory for Mach-V to achieve timing closure at 115 MHz. Reverting to the standard post-mux Zero generation will cause setup time violations on the Vivado tool.</p>"},{"location":"uarch/clock/","title":"Clock Architecture","text":"<p>Consistent with the synchronous design conventions established in NUS CG3207, the Mach-V processor operates within a single clock domain. All registers and sequential logic are driven by a single global clock signal to simplify timing analysis.</p>"},{"location":"uarch/clock/#clock-frequency-scaling","title":"Clock Frequency Scaling","text":"<p>2.0 </p> <p>Given that the default system clock is capped at 100 MHz and limited to coarse power-of-two division, I utilized the AMD Clocking Wizard IP core. This allows me to synthesize a precise, higher-frequency clock from the base input to maximize Mach-V's performance.</p>"},{"location":"uarch/clock/#generate-the-ip-core","title":"Generate the IP Core","text":"<p>To use the IP in Vivado, click the \"IP Catalog\" on the left flow navigator. Then, search for \"clocking wizard\". Click the only option available. And then configure the IP to use the following settings:</p> <ol> <li>In the \"Clocking Options\" tab:<ul> <li>Make sure the primary input clock is <code>clk_in1</code> with a frequency of <code>100 MHz</code>.</li> <li>Make sure the primary input clock source is \"Single ended clock capable pin\".</li> </ul> </li> <li>In the \"Output Clocks\" tab:<ul> <li>Click the <code>clk_out1</code> and set the frequency that you want to achieve.</li> <li>Make sure the \"Reset Type\" is set to \"Active High\".</li> <li>Make sure the \"locked\" option is enabled under the \"Enable Optional Inputs\".</li> </ul> </li> </ol>"},{"location":"uarch/clock/#use-the-ip-core","title":"Use the IP Core","text":"<p>The clock generation logic must be instantiated in the top-level entity (<code>TOP_Nexys.vhd</code>).</p>"},{"location":"uarch/clock/#component-declaration","title":"Component Declaration","text":"<p>Add the component declaration before the architecture <code>begin</code> keyword:</p> Top_Nexys.vhd<pre><code>----------------------------------------------------------------------------\n-- Component: Clocking Wizard\n----------------------------------------------------------------------------\ncomponent clk_wiz_0\nport (\n    -- Clock in ports\n    clk_in1  : in  std_logic;\n    -- Clock out ports\n    clk_out1 : out std_logic;\n    -- Status and control signals\n    reset    : in  std_logic;\n    locked   : out std_logic\n);\nend component;\n\n----------------------------------------------------------------------------\n-- Signals: Clock &amp; Reset Management\n----------------------------------------------------------------------------\nsignal clk_sys    : std_logic; -- The synthesized high-speed system clock\nsignal clk_locked : std_logic; -- High ('1') when the clock is stable\nsignal sys_reset  : std_logic; -- Combined effective system reset\n</code></pre>"},{"location":"uarch/clock/#instantiation","title":"Instantiation","text":"<p>Instantiate the IP core within the architecture body, mapping the board's raw clock to the input:</p> Top_Nexys.vhd<pre><code>----------------------------------------------------------------\n-- Instance: Clocking Wizard\n----------------------------------------------------------------\nclk_wiz_inst : clk_wiz_0\nport map ( \n    clk_in1  =&gt; CLK_undiv,  -- Raw 100MHz from physical board pin\n    clk_out1 =&gt; clk_sys,    -- Synthesized Fast Clock\n    reset    =&gt; RESET,      -- Raw button reset (Active High)\n    locked   =&gt; clk_locked  -- Status signal\n);\n</code></pre>"},{"location":"uarch/clock/#system-reset-logic","title":"System Reset Logic","text":"<p>It is critical to hold the processor in reset until the clock signal is stable. The <code>locked</code> signal from the Clocking Wizard indicates when the output frequency is stable.</p> <p>I generate a <code>RESET_EFF</code> (Effective Reset) signal that is asserted (High) if either:</p> <ol> <li>The physical reset button is pressed (<code>RESET_INT</code> / <code>RESET_EXT</code>).</li> <li>The clock is not yet locked (not <code>clk_locked</code>).</li> </ol> Top_Nexys.vhd<pre><code>-- Original Logic (Raw Button only)\n-- RESET_EFF &lt;= RESET_INT or RESET_EXT;\n\n-- New Logic (Button + Clock Stability Guard)\nRESET_EFF &lt;= RESET_INT or RESET_EXT or (not clk_locked);\n</code></pre>"},{"location":"uarch/clock/#frequency-constant-update","title":"Frequency Constant Update","text":"<p>Finally, ensure the software-visible frequency constant matches the new hardware configuration. This is often used for UART baud rate calculations or timer peripherals.</p> Top_Nexys.vhd<pre><code>-- Update this value to match the Clocking Wizard output\nconstant CLOCK_FREQUENCY : positive := 115000000;\n</code></pre> <p>Warning</p> <p>The <code>CLOCK_FREQUENCY</code> constant is not automatically linked to the IP Core settings. If you reconfigure the Clocking Wizard to a different frequency (e.g., changing from 120MHz to 150MHz), you must manually update the <code>CLOCK_FREQUENCY</code> constant in <code>TOP_Nexys.vhd</code> to ensure correct timing for peripherals like UART.</p>"},{"location":"uarch/hazard-unit/","title":"Hazard Handling Unit","text":"<p>The Hazard Handling Unit manages the data and control hazards inherent in Mach-V's 5-stage pipeline architecture. Its primary responsibilities are divided into two logic blocks:</p> <ol> <li>Data Forwarding Logic: Resolves data hazards by bypassing results from later stages.</li> <li>Stall &amp; Flush Logic: Resolves load-use and control hazards by stalling or clearing pipeline registers.</li> </ol>"},{"location":"uarch/hazard-unit/#forwarding-logic","title":"Forwarding Logic","text":"<p>1.0</p> <p>The stall &amp; flush logic mainly deals with the load-use hazard and control hazard. The version that Mach-V Version 1 uses are also strictly following the rules introduced in NUS CG3207 or in Harris &amp; Harris DDCA.</p> <p>Specific implementation details can be found in the source code Hazard.v and strictly follow the datapath connections shown in the microarchitecture diagram.</p>"},{"location":"uarch/hazard-unit/#stall-flush-logic","title":"Stall &amp; Flush Logic","text":"<p>1.0</p> <p>The base implementation of the Stall &amp; Flush logic handles standard Load-Use hazards and Control hazards, also following NUS CG3207 and DDCA (Harris &amp; Harris) model.</p>"},{"location":"uarch/hazard-unit/#modifications-for-mem-stage-branching","title":"Modifications for Mem Stage Branching","text":"<p>2.0 </p> <p>To support moving the PC Logic to the Memory (Mem) stage, significant modifications were required to the interaction between the Hazard Unit, the Stall signals, and the Multi-Cycle Unit.</p>"},{"location":"uarch/hazard-unit/#priority-inversion-the-lost-jump-scenario","title":"Priority Inversion: The \"Lost Jump\" Scenario","text":"<p>The problem: When a branch/jump instruction reaches the Mem stage and resolves to branch/jump, the instruction immediately following it (the \"ghost\" instruction) is already in the Execute or Decode stage. If this ghost instruction triggers a Hazard Stall (e.g., a Load-Use stall or a Multi-Cycle Busy signal), a conflict arises.</p> <p>In the previous design, the PC update logic prioritized <code>StallF</code> over the new PC target (<code>PC_IN</code>). Because <code>StallF</code> was high (caused by the ghost instruction), the PC retained its current value, effectively ignoring the jump request. This caused the CPU to \"fall through\" and execute instructions that should have been skipped.</p> <p>The Solution: Control flow changes must be prioritized over stall signals. I modified the logic to force stall signals to <code>0</code> whenever a branch or jump is confirmed (<code>PCSrcM</code> is active). This ensures that if the processor is jumping, hazards caused by instructions in the flush shadow are ignored.</p> <pre><code>// Before: Stall logic only looked at hazards\n// assign StallF = lwStall | Busy;\n// assign StallD = lwStall | Busy;\n\n// After: Force Stall to 0 if a branch (PCSrcM[0]) is happening\nassign StallF = (lwStall | Busy) &amp; ~PCSrcM[0];\nassign StallD = (lwStall | Busy) &amp; ~PCSrcM[0];\n</code></pre>"},{"location":"uarch/hazard-unit/#spurious-execution-in-muldiv-operations","title":"Spurious Execution in Mul/Div Operations","text":"<p>The Problem: When a branch/jump instruction takes a branch/jump in the Mem stage, the subsequent instruction (e.g., a <code>mul</code>) may have already advanced to the Execute stage.</p> <p>Although the Hazard Unit asserts <code>FlushE</code> to kill the <code>mul</code> for the next clock cycle, the MCycle Unit is combinational logic that reacts to its inputs instantly. It sees the <code>Start</code> signal immediately in the current cycle, begins the calculation, and raises the <code>Busy</code> flag. This stalls the entire processor to perform a \"fake\" multiplication that is about to be flushed.</p> <p>The Solution: I modified the instantiation of the MCycle Unit in <code>RV.v</code> to logically \"gate\" the start signal. If the Execute stage is currently being flushed (<code>FlushE</code> is high), the <code>.Start</code> input is forced to <code>0</code>. This prevents the unit from activating on instructions that are being discarded.</p> <pre><code>MCycle #(\n    .width(32)\n) MCycle1 (\n    // ... other ports ...\n\n    // Before: The unit starts immediately, ignoring the flush\n    // .Start   (MCycleStartE),\n\n    // After: The unit only starts if we are NOT flushing the stage\n    .Start   (MCycleStartE &amp; ~FlushE), \n\n    .Busy    (Busy)\n);\n</code></pre>"},{"location":"uarch/lsu/","title":"Load &amp; Store Unit","text":"<p>Unlike the baseline design from NUS CG3207, Mach-V extends memory support beyond full-word operations. The Load Store Unit (LSU) module handles byte (<code>lb</code>/<code>lbu</code>/<code>sb</code>) and half-word (<code>lh</code>/<code>lhu</code>/<code>sh</code>) transactions, ensuring correct data alignment and sign extension.</p> <p>The LSU will take 5 inputs and produce 3 outputs:</p>"},{"location":"uarch/lsu/#interface-definition","title":"Interface Definition","text":"<p>The LSU locates in the Mem stage. It processes raw addresses and data to align them with the memory's 32-bit word boundaries.</p> Direction Signal Width Description Input Funct3 3 Instruction function code (determines size and signing). Input MemWriteM 1 Write Enable signal from the Control Unit. Input WriteDataM 32 Raw data to be written. Input ReadData_in 32 Raw 32-bit word read from Data Memory. Input ByteOffset 2 The 2 Least Significant Bits (LSB) of the memory address. Output MemWrite_out 4 Byte-enable mask sent to Data Memory (1 bit per byte). Output WriteData_out 32 Aligned data sent to Data Memory. Output ReadDataM 32 Processed data (shifted/extended) sent to Writeback. <p>Naming Convention</p> <p>The term \"Load Store Unit\" typically refers to a complex buffer system in Out-of-Order processors. In the context of the current Mach-V (Scalar In-Order), it refers specifically to the alignment and formatting logic within the Memory stage.</p>"},{"location":"uarch/lsu/#store-alignment-logic","title":"Store Alignment Logic","text":"<p>1.0</p> <p>The Store Unit is responsible for placing data into the correct \"byte lane\" before writing to memory. Since memory is word-addressed (32-bit width), sub-word stores (like <code>sb</code>) must be shifted to the correct position within the word.</p> <ol> <li>Calculate Shift Amount: The <code>ByteOffset</code> is multiplied by 8 (concatenated with <code>3'b000</code>) to convert the byte index into a bit index.</li> <li>Align Data: The raw <code>WriteDataM</code> is logically left-shifted (<code>&lt;&lt;</code>) by this amount.</li> <li>Generate Mask: A base mask is selected based on the instruction type (e.g., <code>0001</code> for Byte, <code>0011</code> for Half-word) and then shifted to the active position.</li> </ol> <p>Exmaple from NUS CG3207 Teaching Team</p> <p><code>WriteData_out</code> is a word, with word/byte/half-word aligned to where you wish to write it to within the word. The <code>MemWrite_out</code> bits of every byte to be modified should be 1. For example, when running <code>sb</code> (store byte) instruction, if the last 2 bits of the address is <code>2'b10</code> and the byte to be written (<code>WriteDataM</code>) is <code>8'hAB</code> (or <code>32'b000000AB</code>), <code>WriteData_out</code> should be <code>32'hxxABxxxx</code> and <code>MemWrite_out</code> should be <code>4'h0100</code>.</p> <pre><code>// --- STORE PATH (Alignment &amp; Masking) ---\nwire [4:0] shamt = {ByteOffset, 3'b000};  // Offset * 8\n\n// Align Data\nassign WriteData_out = WriteDataM &lt;&lt; shamt;\n\n// Generate Mask\nreg [3:0] BaseMask;\nalways @(*) begin\n    case (Funct3)\n        3'b000: BaseMask = 4'b0001;  // SB\n        3'b001: BaseMask = 4'b0011;  // SH\n        default: BaseMask = 4'b1111;  // SW\n    endcase\nend\n\n// Shift Mask\nassign MemWrite_out = (MemWriteM) ? (BaseMask &lt;&lt; ByteOffset) : 4'b0000;\n</code></pre>"},{"location":"uarch/lsu/#load-extension-logic","title":"Load Extension Logic","text":"<p>1.0</p> <p>The Load Unit performs the inverse operation. It takes a full 32-bit word from memory and extracts the relevant byte or half-word.</p> <ol> <li>Re-Align: The raw <code>ReadData_in</code> is right-shifted (<code>&gt;&gt;</code>) by <code>ByteOffset</code> bits so that the desired data sits in the Least Significant Bits (LSB).</li> <li>Sign Extension: Based on <code>Funct3</code>, the logic decides whether to zero-extend (for <code>lbu</code>, <code>lhu</code>) or sign-extend (for <code>lb</code>, <code>lh</code>) the result to fill the 32-bit register.</li> </ol> <p>Example from NUS CG3207 Teaching Team</p> <p><code>ReadData_in</code> is the whole word that contains the word/half-word/byte you want. You need to extract what you want, with a sign/zero(<code>u</code>) extension as required by the instruction. For example, when running <code>lbu</code> (load byte unsigned) instruction, if the last 2 bits of the address is <code>2'b01</code>, and the address location specified in the instruction has <code>8'hAB</code>, <code>ReadData_in</code> is <code>32'hxxxxABxx</code>. <code>ReadDataM</code>, the word to be written into the destination register is <code>32'h000000AB</code> (<code>0</code>s as MSBs as it is <code>lbu</code>).</p> <pre><code>wire [31:0] data_shifted = ReadData_in &gt;&gt; shamt;\nreg  [31:0] loaded_val;\n\nalways @(*) begin\n    case (Funct3)\n        3'b000: loaded_val = {{24{data_shifted[7]}}, data_shifted[7:0]};  // LB\n        3'b001: loaded_val = {{16{data_shifted[15]}}, data_shifted[15:0]};  // LH\n        3'b100: loaded_val = {24'b0, data_shifted[7:0]};  // LBU\n        3'b101: loaded_val = {16'b0, data_shifted[15:0]};  // LHU\n        default: loaded_val = data_shifted;  // LW\n    endcase\nend\n\nassign ReadDataM = loaded_val;\n</code></pre>"},{"location":"uarch/mul-div-unit/","title":"Multiply &amp; Divide Unit","text":"<p>In this version of the Mach-V processor, the multiply and divide unit is incorporated into one file called <code>MCycle.v</code>. The whole idea of the <code>MCycle</code> module is that, while it is doing the computation, the <code>Busy</code> signal (output) will be triggered high and this signal will be used to stall the other relevant pipeline registers so that no new instructions are fetched until the multiplication/division is complete.</p>"},{"location":"uarch/mul-div-unit/#state-machine-control","title":"State Machine Control","text":"<p>The <code>MCycle</code> module utilizes a finite state machine (FSM) to coordinate the multi-cycle execution of multiplication and division operations. This FSM ensures the <code>Busy</code> signal is asserted correctly during operation and de-asserted only when the result is valid.</p>"},{"location":"uarch/mul-div-unit/#fsm-architecture","title":"FSM Architecture","text":"<p>The controller is designed as a Mealy Machine.</p> <ul> <li>The output is the <code>Busy</code> signal.</li> <li>The inputs are <code>Start</code> and <code>done</code>.</li> </ul> <p>The FSM consists of two states, encoded using a single binary bit:</p> <ul> <li>IDLE (\\(S_0\\)): The unit is waiting for a <code>Start</code> signal.</li> <li>COMPUTING (\\(S_1\\)): The unit is executing the operation.</li> </ul>"},{"location":"uarch/mul-div-unit/#state-transition-diagram","title":"State Transition Diagram","text":"<p>The following diagram illustrates the transitions and output logic. The arc labels follow the convention <code>Input / Output</code>.</p> <p></p> <p>MCycle State Transition Diagram</p>"},{"location":"uarch/mul-div-unit/#state-transition-output-table","title":"State Transition &amp; Output Table","text":"<p>The FSM behavior is summarized in the combined transition and output table below.</p> Current State (\\(S\\)) Input (<code>Start</code>) Input (<code>done</code>) Next State (\\(S'\\)) Output (<code>Busy</code>) IDLE (0) 0 X IDLE (0) 0 IDLE (0) 1 X COMPUTING (1) 1 COMPUTING (1) X 0 COMPUTING (1) 1 COMPUTING (1) X 1 IDLE (0) 0"},{"location":"uarch/mul-div-unit/#next-state-logic","title":"Next State Logic","text":"<p>Based on the Verilog implementation, we can derive the boolean equation for the next state \\(S'\\). We encode \\(S_{\\text{IDLE}} = 0\\) and \\(S_{\\text{COMPUTING}} = 1\\). The next state is high (COMPUTING) if we start a new operation (\\(Start=1\\) in IDLE) or if we are currently computing and not yet finished (\\(done=0\\) in COMPUTING).</p> \\[\\begin{align} S' &amp;= (\\bar{S} \\cdot Start) + (S \\cdot \\overline{done}) \\end{align}\\]"},{"location":"uarch/mul-div-unit/#output-logic","title":"Output Logic","text":"<p>The <code>Busy</code> signal tracks the next state logic exactly in this implementation to ensure 0-cycle response latency.</p> \\[\\begin{align} Busy &amp;= S' \\\\ Busy &amp;= (\\bar{S} \\cdot Start) + (S \\cdot \\overline{done}) \\end{align}\\] <p>Logic Synthesis vs. Manual Equations</p> <p>While I derived the boolean equations above to analyze the underlying logic (the Microscopic View), I do not hard-code these equations in Verilog. I still write the high-level case statement and the synthesis tool will convert the high-level code into the optimized logic gates based on these equations.</p>"},{"location":"uarch/mul-div-unit/#verilog-implementation","title":"Verilog Implementation","text":"<p>The code implements this FSM using a mixed 2-block style approach to separate the combinational logic from the sequential state updates.</p>"},{"location":"uarch/mul-div-unit/#combinational-block","title":"Combinational Block","text":"<p>This block handles both Next State Logic (<code>n_state</code>) and Output Logic (<code>Busy</code>) simultaneously and strictly follows the Mealy machine template introduced in NUS CG3207.</p> <pre><code>always @(*) begin\n    // Default assignments to prevent latches\n    n_state = state;\n    Busy = 1'b0;\n\n    case (state)\n        IDLE: begin\n            if (Start) begin\n                n_state = COMPUTING;\n                Busy = 1'b1;  // Mealy output behavior\n            end\n        end\n        COMPUTING: begin\n            if (done) begin\n                n_state = IDLE;\n                Busy = 1'b0;\n            end else begin\n                n_state = COMPUTING;\n                Busy = 1'b1;\n            end\n        end\n    endcase\nend\n</code></pre>"},{"location":"uarch/mul-div-unit/#sequential-block","title":"Sequential Block","text":"<p>This block updates the state register on the rising edge of <code>CLK</code> .</p> <pre><code>always @(posedge CLK) begin\n    if (RESET) state &lt;= IDLE;\n    else       state &lt;= n_state;\nend\n</code></pre>"},{"location":"uarch/mul-div-unit/#interaction-with-datapath","title":"Interaction with Datapath","text":"<p>The <code>MCycle</code> module is implemented as a Finite State Machine with Datapath. This design pattern separates the control logic (scheduling) from the data processing logic (execution), connected by specific handshake signals.</p>"},{"location":"uarch/mul-div-unit/#the-datapath","title":"The Datapath","text":"<p>The FSM acts as the manager. It has no knowledge of how the multiplication works; it simply tracks status. The Datapath performs the heavy lifting. It contains the \"implicit state\" of the operation, such as the cycle counter or the handshake status of the IP cores.</p> <ol> <li>Initialization (In IDLE): When <code>Start</code> is detected, the datapath captures operands and performs sign analysis (2's complement conversion).</li> <li>Execution (In COMPUTING):<ul> <li>Multiplication: Increments a <code>count</code> register until it matches the IP latency.</li> <li>Division: Waits for the <code>div_out_valid</code> signal from the AXI-Stream IP core.</li> </ul> </li> <li>Completion Signal: When the latency target is met or valid data is received, the Datapath asserts <code>done</code>, instructing the FSM to release the <code>Busy</code> signal.</li> </ol>"},{"location":"uarch/mul-div-unit/#verilog-coding-style-mixed-assignments","title":"Verilog Coding Style: Mixed Assignments","text":"<p><code>MCycle</code> employs a specific Verilog coding style where blocking (<code>=</code>) and non-blocking (<code>&lt;=</code>) assignments are mixed within the sequential <code>always</code> block. This is done to perform complex data processing (like 2's complement conversion) in a single clock cycle without creating unnecessary pipeline stages.</p> Assignment Type Target Variable Examples Hardware Inference Purpose Non-Blocking (<code>&lt;=</code>) <code>Result1</code>, <code>count</code>, <code>abs_op1</code> Physical Register Defines the sequential state updates. Updates happen at the end of the time step (clock edge). Blocking (<code>=</code>) <code>q_temp</code>, <code>sign_op1</code>, <code>is_signed_op</code> Combinational Logic Acts as \"temporary variables\". The value is updated immediately, allowing subsequent lines to use the calculated value within the same clock cycle. <p>For example, during the division post processing period and in the <code>COMPUTING</code> state, we extract the quotient and correct its sign before storing it.</p> <pre><code>// 1. Extract (Blocking: q_temp has valid data immediately)\nq_temp = div_dout[63:32];\n\n// 2. Modify (Blocking: uses the NEW q_temp value from line above)\nif (is_signed_op &amp;&amp; (sign_op1 ^ sign_op2))\n    q_temp = ~q_temp + 1;\n\n// 3. Store (Non-Blocking: Latches the FINAL calculated value)\nResult1 &lt;= q_temp;\n</code></pre>"},{"location":"uarch/mul-div-unit/#implementation-details","title":"Implementation Details","text":"<p>I have tried two implementations for the <code>MCycle</code> module:</p> <ul> <li> <p> Custom RTL Design</p> <p>Implement the multiply and divide unit by \"hand-typped\" Verilog code.</p> <p> View Documentation</p> </li> <li> <p> IP Core Integration</p> <p>Use Xilinx IP cores to implement the multiply and divide unit.</p> <p> View Documentation</p> </li> </ul>"},{"location":"uarch/mul-div-unit/#custom-rtl-design","title":"Custom RTL Design","text":"<p>1.0 </p> <p>This is a follow-up from CG3207 Assignment 3. More specifically, it is my try to finish the first bullet point in the Task 3 of this assignment.</p>"},{"location":"uarch/mul-div-unit/#multiply-unit","title":"Multiply Unit","text":"<p>For the multiply unit, the idea is to \"unroll\" the loop. For the 32-bit multiplication, instead of using 32 cycles to compute the result by shifting 1 bit a time, I generate the partial products for every 8 bits of the multiplier in parallel. So, the temporal product here will be \\(32+8=40\\) bits wide.</p> <pre><code>module Multiplier32x8 (\n    input  [31:0] A,       // The 32-bit full operand\n    input  [ 7:0] B,       // The 8-bit slice\n    output [39:0] Product  // Result (32 + 8 = 40 bits max)\n);\n\n    // // Generate Partial Products (Shift A based on bit position of B)\n    wire [39:0] pp0 = B[0] ? {8'b0, A} : 40'b0;\n    wire [39:0] pp1 = B[1] ? {7'b0, A, 1'b0} : 40'b0;\n    wire [39:0] pp2 = B[2] ? {6'b0, A, 2'b0} : 40'b0;\n    wire [39:0] pp3 = B[3] ? {5'b0, A, 3'b0} : 40'b0;\n    wire [39:0] pp4 = B[4] ? {4'b0, A, 4'b0} : 40'b0;\n    wire [39:0] pp5 = B[5] ? {3'b0, A, 5'b0} : 40'b0;\n    wire [39:0] pp6 = B[6] ? {2'b0, A, 6'b0} : 40'b0;\n    wire [39:0] pp7 = B[7] ? {1'b0, A, 7'b0} : 40'b0;\n\n    // Sum them up (Tree adder is faster, but this simple chain works also)\n    assign Product = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n</code></pre> <p>In this module, the input <code>A</code> is the full 32-bit multiplicand, while <code>B</code> is an 8-bit slice of the multiplier. The output <code>Product</code> is the 40-bit partial product. For the sliced version of the multiplier, it can be implemented as follows in the state machine control:</p> <pre><code>case (count[1:0])\n    2'b00: current_byte_op2 = abs_op2[7:0];\n    2'b01: current_byte_op2 = abs_op2[15:8];\n    2'b10: current_byte_op2 = abs_op2[23:16];\n    2'b11: current_byte_op2 = abs_op2[31:24];\nendcase\n</code></pre> <p>The final product is then obtained by summing up the 4 partial products with appropriate shifts, which can be implemented as follows:</p> <pre><code>case (count)\n    1: mult_acc = mult_acc + partial_product_out;\n    2: mult_acc = mult_acc + (partial_product_out &lt;&lt; 8);\n    3: mult_acc = mult_acc + (partial_product_out &lt;&lt; 16);\n    4: mult_acc = mult_acc + (partial_product_out &lt;&lt; 24);\nendcase\n</code></pre> <p>And lastly, this module is instantiated in the <code>MCycle</code> module as follows:</p> <pre><code>Multiplier32x8 mul_unit (\n    .A      (abs_op1),\n    .B      (current_byte_op2),\n    .Product(partial_product_out)\n);\n</code></pre> Tip <p>This technique can indeed be implementated using <code>for</code> loop in Verilog as follows:</p> <pre><code>module Multiplier32x8 (\n    input  [31:0] A,       // The 32-bit full operand\n    input  [ 7:0] B,       // The 8-bit slice\n    output [39:0] Product  // Result (32 + 8 = 40 bits max)\n);\n\n    // // Generate Partial Products (Shift A based on bit position of B)\n    wire [39:0] pp0 = B[0] ? {8'b0, A} : 40'b0;\n    wire [39:0] pp1 = B[1] ? {7'b0, A, 1'b0} : 40'b0;\n    wire [39:0] pp2 = B[2] ? {6'b0, A, 2'b0} : 40'b0;\n    wire [39:0] pp3 = B[3] ? {5'b0, A, 3'b0} : 40'b0;\n    wire [39:0] pp4 = B[4] ? {4'b0, A, 4'b0} : 40'b0;\n    wire [39:0] pp5 = B[5] ? {3'b0, A, 5'b0} : 40'b0;\n    wire [39:0] pp6 = B[6] ? {2'b0, A, 6'b0} : 40'b0;\n    wire [39:0] pp7 = B[7] ? {1'b0, A, 7'b0} : 40'b0;\n\n    // Sum them up (Tree adder is faster, but this simple chain works also)\n    assign Product = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n</code></pre> <p>This is totally valid. However, the smart synthesizer will generate the same hardware for both implementations.</p> <p>Warning</p> <p>The 8 bits design will still use more hardware than I thought, which will give around 13ns propagation delay. This will limit the Mach-V clock frequency to 50MHz max if the clock wizard is not used!</p>"},{"location":"uarch/mul-div-unit/#divide-unit","title":"Divide Unit","text":"<p>Similarly, I did the unrolling for the divider unit as well. So, instead of getting at most 1 bit of quotient and remainder per cycle. Now, I can get at most 8 bits of quotient and remainder per cycle. This divider unit is implemented using the <code>for</code> loop in Verilog as follows:</p> <pre><code>module DivSlice8 #(\n    parameter width = 32\n) (\n    input      [2*width-1:0] rem_in,   // Current Remainder\n    input      [2*width-1:0] div_in,   // Current Divisor\n    input      [  width-1:0] quot_in,  // Current Quotient (LSW of buffer)\n    output reg [2*width-1:0] rem_out,  // Next Remainder\n    output reg [2*width-1:0] div_out,  // Next Divisor\n    output reg [  width-1:0] quot_out  // Next Quotient\n);\n\n    // Temporary variable for subtraction\n    integer             i;\n    reg     [2*width:0] diff_ext;\n\n    always @(*) begin\n        // Initialize temporary variables with inputs\n        rem_out = rem_in;\n        div_out = div_in;\n        quot_out = quot_in;\n\n        // Perform 8 iterations of division logic (Combinational Loop)\n        for (i = 0; i &lt; 8; i = i + 1) begin\n            // 1. Subtract: Remainder - Divisor\n            diff_ext = {1'b0, rem_out} + {1'b0, ~div_out} + 1'b1;\n\n            // 2. Check Sign\n            if (diff_ext[2*width] == 1'b1) begin\n                // Result Positive: Update Remainder, Shift 1 into Quotient\n                rem_out = diff_ext[2*width-1:0];\n                quot_out = {quot_out[width-2:0], 1'b1};\n            end else begin\n                // Result Negative: Keep Remainder, Shift 0 into Quotient\n                quot_out = {quot_out[width-2:0], 1'b0};\n            end\n\n            // 3. Shift Divisor Right for the next step\n            div_out = {1'b0, div_out[2*width-1:1]};\n        end\n    end\nendmodule\n</code></pre> <p>To use the result from the divider unit, the state machine control can just be modified by updating the current remainder and quotient to be the result from the divider unit after each cycle:</p> <pre><code>if (count &gt; 0) begin\n    rem = next_rem;\n    div = next_div;\n    div_result_buf[width-1:0] = next_quot;\n    div_result_buf[2*width-1:width] = rem[width-1:0];\nend\n</code></pre> <p>And finally, this divider unit is implemented as follows in the <code>MCycle</code> module:</p> <pre><code>DivSlice8 div_unit (\n    .rem_in  (rem),\n    .div_in  (div),\n    .quot_in (div_result_buf[width-1:0]),\n    .rem_out (next_rem),\n    .div_out (next_div),\n    .quot_out(next_quot)\n);\n</code></pre> <p>Warning</p> <p>Using the unrolling techniue in the divider unit here will use a lot of hardware! iirc, the propagation delay is around 66ns for this design! Given that high propagation delay, it is impossible to use this design on Mach-V. So, I moved on to the next section, which is to use Xilinix IP core for the multiply and divide unit.</p>"},{"location":"uarch/mul-div-unit/#ip-core-integration","title":"IP Core Integration","text":"<p>1.0 </p> <p>As mentioned in the previous documentation, if I only use the unrolling technique, it is impossible to reach higher frequency while keeping the cycles for multiplication and division low. Therefore, I decided to use the AMD IP cores (Multiplier and Divider) to implement the multiply and divide unit.</p>"},{"location":"uarch/mul-div-unit/#generate-the-ip-core","title":"Generate the IP Core","text":"<p>The multiplier IP core comes from AMD and can be used in Vivado directly.</p> <p>To use the IP in Vivado, click the \"IP Catalog\" on the left flow navigator. Then, search for \"multiplier\". Click the \"Multiplier\" (not \"Complex Multiplier\"). And then configure the IP to use the following settings:</p> <ol> <li>In the \"Basic\" tab:<ul> <li>Set Multiplier Type to \"Parallel Multiplier\"</li> <li>Set <code>A</code> and <code>B</code> to be \"unsigned\" and \"32-bit\" wide</li> <li>Set Multiplier Construction to \"Use Mults\"</li> <li>Set the Optimization Options to \"Speed Optimized\"</li> </ul> </li> <li>In the \"Output and Control\" tab<ul> <li>Make sure the <code>P</code> (output) is 64-bit wide.</li> <li>Set the Pipeline Stages to 4.</li> </ul> </li> </ol> <p>Tip</p> <p>With the above settings, the multiplier IP core will take 5 cycles to complete and the propagation is safer for the processor to reach 100MHz and higher.</p> <p>Simiarly, the divider IP core also comes from AMD and can be used in Vivado directly.</p> <p>Follow the similar steps as the multiplier IP core, but configure the divider using the following settings:</p> <ol> <li>In the \"Channel Settings\" tab:<ul> <li>Set Algorithm type of \"Radix 2\" and Operand sign to \"unsigned\".</li> <li>Change dividend and divisor width to \"32\".</li> <li>Set the Remainder Type to be \"Remainder\" and fractional width to be \"32\".</li> </ul> </li> <li>In the \"Options\" tab:<ul> <li>Set Clocks per Division to be \"1\".</li> <li>Set the flow control under AXI4-Stream settings to \"Blocking\".</li> <li>Set the optimize goal under AXI4-Stream settings to \"Performance\".</li> </ul> </li> </ol> <p>Tip</p> <p>With the above settings, the divider IP core will take 32 cycles to complete and the propagation is safer for the processor to reach 100MHz and higher.</p>"},{"location":"uarch/mul-div-unit/#use-ip-core","title":"Use IP Core","text":"<p>To use the two IP cores that we have generated above, we just need to know the inputs and outputs of each IP core and then instantiate them in our <code>MCycle.v</code> to replace the multiple unit and the divide unit that we have implemented manually in the previous section.</p> <pre><code>// Multiplier IP: 32x32 Unsigned -&gt; 64-bit Product\nmult_gen_0 my_multiplier (\n    .CLK(CLK),\n    .A  (abs_op1),\n    .B  (abs_op2),\n    .P  (mul_dout)\n);\n\n// Divider IP: 32/32 Unsigned -&gt; 32 Quot, 32 Rem\ndiv_gen_0 my_divider (\n    .aclk                  (CLK),\n    .s_axis_divisor_tvalid (div_in_valid),\n    .s_axis_divisor_tdata  (abs_op2),\n    .s_axis_dividend_tvalid(div_in_valid),\n    .s_axis_dividend_tdata (abs_op1),\n    .m_axis_dout_tvalid    (div_out_valid),\n    .m_axis_dout_tdata     (div_dout)\n);\n</code></pre>"},{"location":"uarch/pc-unit/","title":"PC Logic","text":"<p>This section details the implementation of the Program Counter (PC) logic, covering <code>PC_Logic.v</code>, <code>ProgramCounter.v</code>, and the relevant multiplexing logic for the PC adder within <code>RV.v</code>.</p>"},{"location":"uarch/pc-unit/#move-pc-logic-to-mem-stage","title":"Move PC Logic to Mem Stage","text":"<p>2.0 </p> <p>In Mach-V Version 2, the PC logic was relocated from the Execute (Exe) stage to the Memory (Mem) stage. This architectural change implies that branch and jump instructions are now committed in the Mem stage. This optimization significantly improved timing performance, allowing Mach-V to achieve a clock frequency of 115 MHz (utilizing the Clocking Wizard IP).</p> <p>To support this transition, the input logic for the PC Adder was redesigned as follows:</p> <ol> <li><code>PC_Base</code> Selection: The base address multiplexer now accepts three new inputs:<ul> <li><code>PCF</code>: For sequential execution (Branch Not Taken).</li> <li><code>PCM</code>: For conditional branches (Branch Taken).</li> <li><code>RD1M</code>: For jump instructions. Note that <code>RD1M</code> is derived from <code>RD1E_Forwarded</code> and latched into the Mem stage pipeline register.</li> </ul> </li> <li><code>PC_Offset</code> Selection: The offset multiplexer now selects between <code>4</code> (sequential) or <code>ExtImmM</code> (branch/jump targets).</li> </ol> <p>Following the PC adder updates, the <code>PC_Logic</code> module itself was simplified. The control signals <code>PCSE</code> and <code>ALUFlagsE</code> are propagated through the pipeline registers to become <code>PCSM</code> and <code>ALUFlagsM</code>. These are then fed into the PC Logic unit in the Mem stage, generating the final branch decision signal, <code>PCSrcM</code>.</p> <p>Info</p> <p>The updated microarchitecture diagram illustrating the move of PC Logic to the Mem stage can be found in Mach-V Version 2's microarchitecture diagram.</p> <p>Warning</p> <p>Simply delaying the control signals is insufficient for this architectural change. The Hazard Unit must also be updated to handle the new branch resolution timing correctly.</p>"}]}