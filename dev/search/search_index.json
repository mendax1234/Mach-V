{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hydra-V Processor","text":"<p>Welcome to the documentation for Hydra-V, a custom RISC-V processor implementation targeting the Nexys 4 DDR FPGA.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>ISA: RISC-V RV32I Base Integer Instruction Set</li> <li>Pipeline: 5-Stage Classic (Fetch, Decode, Execute, Memory, Writeback)</li> <li>Hazard Handling: Full Forwarding Unit + Stall Logic</li> <li>Peripherals: UART, GPIO, Seven-Segment Display</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the User Guide to run your first program, or view the Verification section to run the testbench.</p>"},{"location":"architecture/hazard/","title":"Hazards &amp; Complex Logic","text":"<p>This section details how the Hydra-V processor handles data and control hazards to maintain pipeline throughput.</p>"},{"location":"architecture/hazard/#data-hazards","title":"Data Hazards","text":"<p>Data hazards occur when an instruction depends on the result of a previous instruction that has not yet been committed to the Register File.</p>"},{"location":"architecture/hazard/#forwarding-unit","title":"Forwarding Unit","text":"<p>To resolve Read-After-Write (RAW) hazards without stalling, we implement a Full Forwarding Unit. This unit bypasses data from the <code>EX</code> or <code>MEM</code> stages directly to the ALU inputs.</p> Source Stage Condition Forwarding Path Priority EX/MEM <code>rd == rs1</code> or <code>rd == rs2</code> ALU Result \\(\\rightarrow\\) ALU Input High MEM/WB <code>rd == rs1</code> or <code>rd == rs2</code> Writeback Data \\(\\rightarrow\\) ALU Input Low"},{"location":"architecture/hazard/#load-use-hazard","title":"Load-Use Hazard","text":"<p>Forwarding cannot solve a \"Load-Use\" hazard because the data comes from Data Memory (available in WB) but is needed immediately in EX.</p> <ul> <li>Solution: The pipeline stalls for 1 cycle.</li> <li>Signal: <code>stall_IF_ID</code> and <code>stall_ID_EX</code> go HIGH; <code>flush_EX</code> goes HIGH.</li> </ul>"},{"location":"architecture/hazard/#control-hazards-branching","title":"Control Hazards (Branching)","text":"<p>The pipeline needs to know the next PC address in the Fetch stage, but the Branch/Jump decision is made in the Execute (EX) stage.</p> <p>Static Prediction</p> <p>The current implementation uses \"Assume Not Taken\" static prediction.</p>"},{"location":"architecture/hazard/#flushing-logic","title":"Flushing Logic","text":"<p>If a branch is taken:</p> <ol> <li>The instructions currently in Fetch and Decode are wrong.</li> <li>The Control Unit asserts <code>flush_ID</code> and <code>flush_EX</code>.</li> <li>These instructions become <code>NOP</code> (bubbles).</li> <li>The PC is updated to the <code>Branch Target</code>.</li> </ol>"},{"location":"architecture/hazard/#verilog-implementation-details","title":"Verilog Implementation Details","text":"<p>Here is a snippet of the Forwarding Logic implemented in the Core:</p> <pre><code>// Forwarding Logic for Operand A\nalways @(*) begin\n    if ((ex_mem_reg_write) &amp;&amp; (ex_mem_rd != 0) &amp;&amp; (ex_mem_rd == id_ex_rs1)) begin\n        // Forward from ALU Result (EX/MEM pipeline register)\n        forward_a = 2'b10;\n    end\n    else if ((mem_wb_reg_write) &amp;&amp; (mem_wb_rd != 0) &amp;&amp; (mem_wb_rd == id_ex_rs1)) begin\n        // Forward from Writeback (MEM/WB pipeline register)\n        forward_a = 2'b01;\n    end\n    else begin\n        // No forwarding (use Register File output)\n        forward_a = 2'b00;\n    end\nend\n</code></pre>"},{"location":"architecture/pipeline/","title":"Pipeline Design","text":"<p>The Hydra-V uses a classic 5-stage pipeline.</p>"},{"location":"architecture/pipeline/#datapath-diagram","title":"Datapath Diagram","text":""},{"location":"architecture/pipeline/#stage-breakdown","title":"Stage Breakdown","text":""},{"location":"architecture/pipeline/#1-instruction-fetch-if","title":"1. Instruction Fetch (IF)","text":"<ul> <li>PC Logic: Updates program counter by \\(+4\\) or branch target.</li> <li>Instruction Memory: Single-cycle read latency.</li> </ul>"},{"location":"architecture/pipeline/#2-decode-id","title":"2. Decode (ID)","text":"<ul> <li>Register File: Dual read ports, single write port.</li> <li>Control Unit: Generates signals based on Opcode/Funct3.</li> </ul> <pre><code>graph LR\n    IF[Fetch] --&gt; ID[Decode];\n    ID --&gt; EX[Execute];\n    EX --&gt; MEM[Memory];\n    MEM --&gt; WB[Writeback];\n    style EX fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/pipeline/#3-execute-ex","title":"3. Execute (EX)","text":"<p>The computational heart of the processor.</p> <ul> <li>ALU (Arithmetic Logic Unit): Performs Add, Sub, AND, OR, XOR, SLL, SRL, SRA.</li> <li>Branch Comparator: Compares operands for <code>BEQ</code>, <code>BNE</code>, <code>BLT</code>, etc.</li> <li> <p>Branch Target Calculation:</p> \\[ \\text{Target} = PC_{\\text{current}} + (\\text{Immediate} \\ll 1) \\] </li> </ul>"},{"location":"architecture/pipeline/#4-memory-access-mem","title":"4. Memory Access (MEM)","text":"<p>Handles Load and Store instructions.</p> <ul> <li>Data Memory: Reads or writes data if <code>MemRead</code> or <code>MemWrite</code> is high.</li> <li>IO Mapping: Addresses in the <code>0x8000_XXXX</code> range bypass RAM and go to MMIO (Memory Mapped IO) for peripherals like LEDs and UART.</li> </ul>"},{"location":"architecture/pipeline/#5-writeback-wb","title":"5. Writeback (WB)","text":"<p>The final stage where results are committed.</p> <ul> <li>Multiplexer: Selects data from either ALU Result, Data Memory, or PC+4 (for JAL/JALR).</li> <li>Register Write: The selected data is written back to the destination register <code>rd</code>.</li> </ul>"},{"location":"sim/simulation/","title":"Verification &amp; Simulation","text":"<p>This section outlines the verification strategy for the Hydra-V processor, including unit testing and full system simulation.</p>"},{"location":"sim/simulation/#simulation-directory-structure","title":"Simulation Directory Structure","text":"<p>The <code>sim/</code> directory contains all testbench and verification artifacts:</p> <ul> <li><code>sim/tb/</code>: Verilog testbenches for individual modules (ALU, RegFile) and the top-level core.</li> <li><code>sim/hex/</code>: Pre-compiled hexadecimal files (machine code) loaded into instruction memory for simulation.</li> </ul>"},{"location":"sim/simulation/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following tools installed:</p> <ol> <li>Xilinx Vivado (for Behavioral Simulation)</li> <li>Verilator (Optional, for faster C++ based simulation)</li> <li>GTKWave (for viewing waveform dumps outside Vivado)</li> </ol>"},{"location":"sim/simulation/#running-simulations","title":"Running Simulations","text":""},{"location":"sim/simulation/#unit-level-testing","title":"Unit Level Testing","text":"<p>Unit tests verify specific components before integration.</p> <pre><code># Example: Running the ALU testbench\ncd sim/tb\nxvlog alu.v alu_tb.v\nxelab -debug typical alu_tb -s alu_sim\nxsim alu_sim -R\n</code></pre>"},{"location":"sim/simulation/#top-level-system-test","title":"Top Level System Test","text":"<p>To verify the full processor pipeline:</p> <ol> <li>Load a program hex file into <code>sim/hex/main.hex</code>.</li> <li>Run the top-level testbench <code>tb_core.v</code>.</li> <li>Observe the <code>d_mem</code> and register file changes.</li> </ol> <p>Debugging with Waveforms</p> <p>If the processor stalls, check the stall_signal and flush lines in the Waveform viewer. A permanent high signal usually indicates a lockup in the Hazard Unit.</p>"},{"location":"sw/contributing/","title":"Documentation Workflow","text":"<p>The Hydra-V documentation uses mike to manage multiple versions (e.g., <code>1.0</code>, <code>dev</code>). This process is automated via GitHub Actions.</p>"},{"location":"sw/contributing/#1-daily-development-dev","title":"1. Daily Development (<code>dev</code>)","text":"<p>Any commit pushed to the <code>main</code> branch automatically triggers a deployment to the dev version.</p> <ul> <li>URL: <code>.../Hydra-V/dev/</code></li> <li>Behavior: This version is mutable. New pushes overwrite the previous <code>dev</code> content.</li> </ul>"},{"location":"sw/contributing/#2-publishing-a-release-vxx","title":"2. Publishing a Release (<code>vX.X</code>)","text":"<p>To \"freeze\" the documentation for a specific processor version (e.g., when Version 1.0 RTL is complete), use Git Tags. The CI pipeline detects tags starting with <code>v</code> and creates a permanent documentation snapshot.</p> <p>Steps to release:</p> <ol> <li>Commit your final changes.</li> <li>Tag the commit with the version number (e.g., <code>v1.0</code>).</li> <li>Push the tag to GitHub.</li> </ol> <pre><code># Example: Releasing Version 1.0\ngit commit -am \"Finalize RTL and Docs for v1.0\"\ngit tag v1.0\ngit push origin v1.0\n</code></pre> <p>Results:</p> <ul> <li>A new folder <code>/1.0/</code> is created in the documentation.</li> <li>The <code>latest</code> alias is updated to point to <code>1.0</code>.</li> <li>The default landing page is switched to <code>1.0</code>.</li> </ul>"},{"location":"sw/contributing/#3-pdf-offline-access","title":"3. PDF / Offline Access","text":"<p>The documentation supports exporting the entire site as a single consolidated PDF using the <code>mkdocs-print-site-plugin</code>.</p> <p>How to access: There is currently no direct icon in the navigation bar. To access the printable version, you must manually navigate to the print page:</p> <ol> <li> <p>Navigate to the Print URL:     Append <code>/print_page/</code> (or <code>print_page.html</code>) to the end of the current documentation URL.</p> <ul> <li>Example: <code>.../Hydra-V/dev/print_page/</code></li> </ul> </li> <li> <p>Save as PDF:     Once the consolidated page loads (containing all documentation chapters), use your browser's print function:</p> <ul> <li>Press <code>Ctrl + P</code> (Windows/Linux) or <code>Cmd + P</code> (macOS).</li> <li>Select \"Save as PDF\" as the destination.</li> </ul> </li> </ol>"},{"location":"sw/software/","title":"Software Development Guide","text":"<p>This guide explains how to write, compile, and deploy software for the Hydra-V processor.</p>"},{"location":"sw/software/#software-directory-structure","title":"Software Directory Structure","text":"<p>The <code>sw/</code> directory is organized by application:</p> <ul> <li><code>sw/coremark/</code>: The industry-standard CoreMark benchmark ported for this architecture.</li> <li><code>sw/oled-demo/</code>: Drivers and demo code for the OLED display on the Nexys 4.</li> </ul>"},{"location":"sw/software/#memory-map","title":"Memory Map","text":"<p>The processor uses a flat 32-bit address space.</p> Address Range Size Device Description <code>0x0000_0000</code> 64 KB Instruction Memory Read-Only program storage (BRAM). <code>0x0010_0000</code> 64 KB Data Memory Read/Write RAM for stack and variables. <code>0x8000_0000</code> 4 B GPIO_LEDS Write logic <code>1</code> to turn on board LEDs. <code>0x8000_0004</code> 4 B UART_TX Write a character (byte) to send via Serial."},{"location":"sw/software/#toolchain-setup","title":"Toolchain Setup","text":"<p>You need the RISC-V GNU Toolchain to compile C code into machine code.</p> <ol> <li> <p>Install Toolchain:</p> <pre><code>sudo apt-get install gcc-riscv64-unknown-elf\n</code></pre> </li> <li> <p>Compilation Steps:     We treat the processor as \"Bare Metal\" (no Operating System).</p> <pre><code># 1. Compile C to Object\nriscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 -c main.c -o main.o\n\n# 2. Link (using custom linker script)\nriscv64-unknown-elf-ld -T linker.ld main.o -o main.elf\n\n# 3. Generate Hex File (for Verilog $readmemh)\nriscv64-unknown-elf-objcopy -O verilog main.elf main.hex\n</code></pre> </li> </ol>"},{"location":"sw/software/#example-oled-demo","title":"Example: OLED Demo","text":"<p>To run the OLED demo located in <code>sw/oled-demo/barebones</code>:</p> <ol> <li>Navigate to the folder.</li> <li>Run <code>make hex</code>.</li> <li>Copy the generated <code>.hex</code> file to <code>sim/hex/</code> for simulation or <code>fpga/</code> for synthesis.</li> </ol>"}]}